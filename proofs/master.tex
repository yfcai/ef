\documentclass{amsart}
\usepackage{bcprules,url,enumerate}
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[subsection]{Definition}

\def\thesubsection{\arabic{subsection}}

\title{Nuclear Football Megaslave}

\input{../paper/macros.tex}
\begin{document}

\maketitle
\tableofcontents

\subsection{Syntax}
\begin{syntax}
\mbox{type}\\
\sigma, \tau
&::=& \iota_0 \Or \iota_1 \Or \cdots &\mbox{base type}\\
&|& \alpha \Or \beta \Or \cdots & \mbox{type variable} \\
&|& \tau \rightarrow \tau & \mbox{function type} \\
&|& \All\alpha\tau & \mbox{universal type} \\
&|& \Ex\alpha\tau & \mbox{existential type}
\\
\\
\mbox{term}\\
s, t & ::= & x & \mbox{variable} \\
& | & \Abs{x}t  & \mbox{lambda abstraction} \\
& | & t~t & \mbox{function application} \\
& | & \cdots & \mbox{primitives}
\end{syntax}

\subsection{Domain}
The domain of values $V$ is the solution to the following domain
equations.
\begin{align*}
V &= F + B_0 + B_1 + \cdots + \{\Wrong\}
  &&\mbox{disjoint sum of domains}\\
F &= V \R V &&\mbox{continuous functions from $V$ to $V$}
\end{align*}
Here and elsewhere, we omit all domain-theoretic details, such as
the fact that domain equations are solved only up to isomorphism,
and that disjoint sum with a bottomless set (say, $\{\Wrong\}$)
must be encoded as smash sum with a flat domain. To lighten
notational and conceptual burden, let us treat $B_i$, $F$ and
$\{\Wrong\}$ as if they were actual subsets of $V$.

\subsection{Denotation of terms}
\label{denotation-terms}
Terms denote values as in untyped lambda calculus. Primitives may
denote anything in $V$, as long as the value of each primitive
operator satisfies strong type soundness.

Upper case $\Env$ will refer to type-level environments
(\S\ref{denotation-types}). Lower case $\env$ refers to a
term-level environment mapping term variables to values in $V$.
\begin{align*}
\Sem{x}~\env&=\env(x)\\
\Sem{\Abs{x}t}~\env&=
  f\in F\text{\quad such that\quad}
  f(v)=\Sem{t}~(\Update\env{x\mapsto v})
\\
\Sem{s~t}~\env&=
\begin{cases}
\bot&\text{if }(\Sem{s}~\env)=\bot
\\
f(\Sem{t}~\env)&\text{if }(\Sem{s}~\env)=f\in F
\\
\Wrong&\text{if }(\Sem{s}~\env)\notin F\cup\{\bot\}
\end{cases}
\\
\Sem{\mathrm{primitive}}~\env&=\cdots
\end{align*}

\subsection{Wrongless downsets}
\label{wrongless}
Closed types denote wrongless downsets. A subset $S$ of the
domain $V$ is \emph{downward closed} if for all $u\in S$, all
elements preceding $u$ in $V$ are contained in $S$. A subset of
$V$ is a \emph{wrongless downset} if it is nonempty, downward
closed and does not contain $\Wrong$. Write $\Down$ for the
family of all wrongless downsets. $\Down$~is never empty;
$\{\bot\}$ is a wrongless downset, for example.

Nonemptiness and downward closedness are not used in the type
soundness proof. They are relevant only to make $\bot$ a member
of every type. For type soundness, it is sufficient for the
family of type denotations to be closed under arbitrary nonempty
unions and intersections. Hamkins's construction~\cite{Hamkins10}
shows that every such family is a collection of downward-closed
sets with respect to some partial order. The inherent partial
order of the domain $V$ assigns somewhat familiar values to
types~(\S\ref{free-theorems}), and so we employ it here.

We say ``$u$ precedes $v$'' to mean that $u$, $v$ are related by
the inherent partial order in the domain $V$. Intuitively, if $u$
precedes $v$, then $u$ has at most as much information as $v$ and
the information in $u$ never conflicts with the information in
$v$. The function undefined everywhere precedes the function that
acts as the identity between integers and is undefined elsewhere,
which in turn precedes the identity function over all of $V$.

\subsection{Functionality of wrongless downsets}
\label{functionality}
Let $S_0$ and $S_1$ be wrongless downsets. The
\emph{functionality} from $S_0$ to $S_1$, writ $S_0\RR S_1$, is
the set that consists of $\bot$ and all functions who always map
values in $S_0$ to values in $S_1$, but may map values outside
$S_0$ to anything in $V$, including $\Wrong$.
\[
S_0 \RR S_1 =
\{\bot\}\cup\{f\in F \Or f(S_0) \subseteq S_1\}.
\]
Function types denote functionalities. Functionalities are
defined to be inclusive enough to contain all appropriate
polymorphic function values. The functionality from integers to
integers will also contain the identity function on all of $V$,
for example.

The functionality of wrongless down\-sets is the trivial
generalization of Milner's adaptation of Scott's notion of
functionality of ideals to wrongless downsets~\cite{Milner78}.

\subsection{Closure properties of wrongless downsets}
The functionality between two wrongless downsets is a wrongless
downset. The intersection of any nonempty family of wrongless
downsets is a wrongless downset. The union of any nonempty family
of wrongless downsets is a wrongless downset.

\subsection{Denotation of types}
\label{denotation-types}
Closed types denote wrongless downsets. Open types denote a
partial function mapping an environment of wrongless downsets to
a wrongless downset.

Upper case $\Env$ refers to a type-level environment mapping type
variables to wrongless downsets. Lower case $\env$ refers to a
term-level environment mapping term variables to values
(\S\ref{denotation-terms}).
\begin{align*}
\Sem{\iota_i}~\Env &= \{\bot\}\cup B_i\\
\Sem{\alpha}~\Env &= \Env(\alpha)\\
\Sem{\sigma\R\tau}~\Env&=
  (\Sem{\sigma}~\Env)\RR(\Sem{\tau}~\Env)\\
\Sem{\All\alpha\tau}~\Env&=
  {\textstyle\bigcap_{S\in\Down}}
  \left(\Sem\tau~(\Update\Env{\alpha\mapsto S})\right)\\
\Sem{\Ex\alpha\tau}~\Env&=
  {\textstyle\bigcup_{S\in\Down}}
  \left(\Sem\tau~(\Update\Env{\alpha\mapsto S})\right)
\end{align*}
The reader may verify that the right hand side of this definition
is always a wrongless downset. The family $\Down$ of all
wrongless downsets is defined in \S\ref{wrongless}. The
functionality construction $\RR$ is described in
\S\ref{functionality}.

\subsection{Examples of type denotations}
\label{free-theorems}
~
\begin{enumerate}[(a)]
\item $\Sem{\All\alpha\alpha}~\emptyset=\{\bot\}$
\item $\Sem{\Ex\alpha\alpha}~\emptyset=V-\{\Wrong\}$
\item $\Sem{\All\alpha\alpha\R\alpha}~\emptyset=\{\bot\}\cup
\{f\in F
\Or
f(v)\text{ precedes }v\text{ for all }v\neq\Wrong
\}$
\end{enumerate}

Equation (a) holds because $\{\bot\}$ is a wrongless downset and
all wrongless downsets, by their nonemptiness and downward
closedness, contains $\bot$.

Equation (b) holds because $V-\{\Wrong\}$ is a wrongless downset
that is a superset of every wrongless downset.

Equation (c) says that every member $f$ of the type
$\All\alpha\alpha\R\alpha$ maps each value~$v$ either to itself
or to a less informative version of itself. If $n$ is an integer,
then $f(n)$ would have to be $n$ or $\bot$. \S\ref{wrongless}
contains a discussion about the intuition behind the inherent
partial order of a domain invoked in the phrase ``$f(v)$ precedes
$v$''.

For (c), we show that its left hand side and right hand side are
subsets of each other. The $\supseteq$ direction holds due to
the definition of functionality, and because $\bot$ is a member
of every wrongless downset. The $\subseteq$ direction requires
case analysis. Choose
$f\in\Sem{\All\alpha\alpha\R\alpha}~\emptyset$. If $f=\bot$, then
$f$ is a member of the right hand side. If $f\neq\bot$, then
$f\in F$, as it is a member of some functionality.
\begin{enumerate}
\item $f(\bot)=\bot$, because $\{\bot\}$ is a wrongless downset
and $f\in(\{\bot\}\RR\{\bot\})$.
\item If $v\notin\{\bot,\Wrong\}$, then $f(v)$ precedes $v$,
because the set $S$ of everything that preces or equals $v$ is a
wrongless downset, and $f$ is a member of $S\RR S$.
\end{enumerate}
It follows that $f(v)$ precedes $v$ for all $v\ne\Wrong$.

\subsection{Equivalence of types}
Set-theoretic equality of the denotation of types induce an
equivalence relation on types. Examples:
\begin{enumerate}[(i)]
\item
$\Sem{\All\alpha\sigma\R\tau}=\Sem{\sigma\R(\All\alpha\tau)}$
\quad if\quad $\alpha\notin\FTV(\sigma)$,
\item
$\Sem{\Ex\alpha\sigma\R\tau}=\Sem{\sigma\R(\Ex\alpha\tau)}$
\quad if\quad $\alpha\notin\FTV(\sigma)$,
\item
$\Sem{\All\alpha\sigma\R\tau}=\Sem{(\Ex\alpha\sigma)\R\tau}$
\quad if\quad $\alpha\notin\FTV(\tau)$,
\item
$\Sem{\Ex\alpha\sigma\R\tau}=\Sem{(\All\alpha\sigma)\R\tau}$
\quad if\quad $\alpha\notin\FTV(\tau)$,
\item
$\Sem{\All\alpha\Ex\beta\tau}=\Sem{\Ex\beta\All\alpha\tau}$.
\end{enumerate}
Types on either side of (i), (ii) are equisatisfiable as
propositions of intuitionistic logic. Types on either side of
(iii), (iv) are equisatisfiable as propositions of classical
logic. The equivalence expressed by (v) is seen in neither.


\subsection{Syntax of subtype judgements}

We define a syntactic relation $\Sub$ on types. We call it the
\emph{subtype} relation because for closed types $\sigma$,
$\tau$, the relation $\sigma \Sub \tau$ implies that the
wrongless downset denoted by $\sigma$ is a \emph{subset} of the
wrongless downset denoted by $\tau$ (\S\ref{subsound}).

The symbol $\Sub$ stands for the partial order between values of
a domain in literature about domain theory. At the same time,
$\Sub$ stands for the ``more general'' partial order between
types in literature about parametric polymorphism. Our use of
$\Sub$ agrees with the latter.

\begin{syntax}
\mbox{list of type variables}\\
A,E
&::=& \emptyset \\
&|& \alpha,A
\\
\\
\mbox{list of constraints}\\
C
&::=& \emptyset \\
&|& \sigma \Sub \tau, C
\\
\\
\mbox{subtype judgement}
&::=&A;E\vdash C
\end{syntax}

In a judgement $A;E\vdash C$, the type variables in $A$ represent
wrongless downsets that can be chosen later so that constraints
in $C$ hold; they are \emph{accommodating}. The type variables in
$E$ represent demands that the constraints in $C$ must be
satisfiable whichever downsets are chosen for them; they are
\emph{exigent}.

\subsection{Derivation of subtype judgements}~

\infrule[S-Refl]
{\FTV(\tau_0)\subseteq A\cup E
\andalso
\cdots
\andalso
\FTV(\tau_n)\subseteq A\cup E
}
{A;E \vdash \tau_0\Sub\tau_0,\tau_1\Sub\tau_1,
\ldots,\tau_n\Sub\tau_n}

\infrule[S-Arrow]
{A;E\vdash\tau_0\Sub\sigma_0,\sigma_1\Sub\tau_1,C}
{A;E\vdash\sigma_0\R\sigma_1\Sub\tau_0\R\tau_1,C}

\infrule[S-Loner]
{\alpha\notin A\cup E\cup\FTV(C)
\andalso
A;E\vdash
\{ \sigma_i\Sub\tau_j \Or 0 \le i \le m, 0 \le j \le n \}
\cup C
}{
\alpha,A;E \vdash
\sigma_0\Sub\alpha,\ldots,\sigma_m\Sub\alpha,
\alpha\Sub\tau_0,\ldots,\alpha\Sub\tau_n,C
}

\infrule[S-Al]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
\alpha,A;E\vdash\sigma\Sub\tau,C}
{A;E\vdash(\All\alpha\sigma)\Sub\tau,C}

\infrule[S-Ar]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
\alpha,A;E\vdash\sigma\Sub\tau,C}
{A;E\vdash\sigma\Sub(\Ex\alpha\tau),C}

\infrule[S-El]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
A;\alpha,E\vdash\sigma\Sub\tau,C}
{A;E\vdash(\Ex\alpha\sigma)\Sub\tau,C}

\infrule[S-Er]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
A;\alpha,E\vdash\sigma\Sub\tau,C}
{A;E\vdash\sigma\Sub(\All\alpha\tau),C}

% Reason of existence: T-App.
\infrule[S-Forget]
{C_0\subseteq C_1\andalso A;E\vdash C_1}
{A;E\vdash C_0}

\subsection{Accommodating extensions of exigent environments}
This is a concept necessary to appreciate how an open type can be
a subtype of another.

With respect to a subtype judgement $A;E\vdash C$, an environment
$\Env_0$ of wrongless downsets is an \emph{exigent environment}
if it is defined for every type variable in $E$ and nowhere else.
$\Env$ is an \emph{accommodating extension} of $\Env_0$ if $\Env$
is defined for every type variable in $A$ and agrees with
$\Env_0$ on $E$.

\subsection{Soundness of subtyping}
\label{subsound}
If the subtype judgement $A;E\vdash C$ is derivable, then every
exigent environment $\Env_0$ has an accommodating extension
$\Env$ such that for every constraint $\sigma\Sub\tau$ in $C$ we
have
\[
\Sem{\sigma}~\Env \quad \subseteq \quad \Sem{\tau}~\Env.
\]

\begin{proof}
Straightforward induction on a derivation of the subtype judgement.
\end{proof}

\subsection{Constrained typing}
\begin{syntax}
\mbox{constrained type}
&::=&\tau \Given C
\\\\
\mbox{constrained typing judgement}
&::=&A;E;\Gamma \vdash t : \tau \Given C
\end{syntax}

\infrule[CT-Var]
{x:\tau\in\Gamma}
{A;\Gamma\vdash x : \tau \Given \emptyset}

\infrule[CT-Abs]
{\FTV(\sigma)\subseteq A
\andalso
A;\Gamma,x:\sigma \vdash t : \tau \Given C}
{A;\Gamma\vdash (\Abs{x}t) : \sigma\R\tau \Given C}

\infrule[CT-App]
{\alpha,\beta\text{ fresh}
\andalso
A;\Gamma\vdash s : \sigma \Given C_1
\andalso
A;\Gamma\vdash t : \tau \Given C_2}
{\alpha,\beta,A;\Gamma\vdash s~t : \beta \Given
\sigma\Sub\alpha\R\beta,\tau\Sub\alpha,C_1\cup C_2}

\subsection{Denotation of typing contexts}
The denotation of a typing context $\Gamma$ is a partial function
mapping an type-level environment to the set of compatible
term-level environments.
\begin{align*}
\Sem{\Gamma}~\Env&=
\left\{\env \Or
\env(x)\in(\Sem{\tau}~\Env)\text{ whenever }x:\tau\in\Gamma
\right\}
\end{align*}

\subsection{Soundness of constrained typing}
\label{consound}
If
$A;\Gamma\vdash t : \sigma\Given C$ and
$A;\emptyset\vdash{\sigma\Sub\tau},C$
are both derivable, then there exist a type-level $\Env$ such
that for every term-level $\env\in(\Sem{\Gamma}~\Env)$ we have
$(\Sem{t}~\env)\in(\Sem{\tau}~\Env)$.

\begin{proof}
A fun and not-at-all complicated induction on typing derivations.
\end{proof}

\subsection{Well-typed programs don't go wrong}~

\infrule[T]
{
A;\emptyset\vdash\sigma\Sub\tau,C
\andalso
A;\Gamma\vdash t : \sigma\Given C
}
{t:\tau}

A term $t$ has type $\tau$, writ $t:\tau$, if both
$A;\Gamma\vdash t : \sigma\Given C$ and
$A;\emptyset\vdash\sigma\Sub\tau,C$ are derivable for some $A$,
$\Gamma$.

If $t:\tau$ with $t$, $\tau$ both closed, then
$\Sem{t}~\emptyset~\in~\Sem{\tau}~\emptyset$. In particular,
$\Sem{t}~\emptyset\neq\Wrong$. This is a corollary of
\S\ref{consound}.



\input{bib.tex}\end{document}
