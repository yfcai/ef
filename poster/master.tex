\documentclass[a0]{a0poster}
\input header

\TPGrid[40mm,40mm]{111}{76}
% dimension   = 1189mm x 841mm
% sans margin = 1109 x 761 (1109 is prime)
% cell size   = 9.99 x 10.1 (same as tikz's cm)

\parindent=0pt
\parskip=0.5\baselineskip

%\usepackage[letterspace=25]{microtype}
\usepackage{tikz,pbox,amssymb}
\usetikzlibrary{backgrounds}

\def\FONTSIZE#1{\fontsize{#1}{#1}\selectfont}

\def\HEAD#1{{\FONTSIZE{76}#1}}

\newenvironment{CODE}{\tt\FONTSIZE{36}\null}{}

\begin{document}
\raggedright
\FONTSIZE{48}

% PROLOGUE
\begin{textblock}{37}(0,0)%
\HEAD{Origin}

The soundness proof of a type system designed for pattern
matching on Church-encoded datatypes turned out to work for many
other type systems.

% maybe some colors eventually?
\begin{CODE}
type List a = forall r.~r -> (a -> r -> r) -> r\\
match ::~List a -> b -> (a -> List a -> b) -> b\\
head xs = match xs undefined const\\
tail xs = match xs undefined (const id)\\
\end{CODE}
\end{textblock}

% TITLE
\begin{textblock}{71}(40,0)
{\FONTSIZE{320}%\lsstyle
PLUGGABLE\\%[0.1ex]
IDEALS
}
\end{textblock}

% WHAT IT IS
\begin{textblock}{34}(0,19)
\HEAD{What is it?}

An extensible notion of type soundness for purely functional
languages, preserved by taking union of type systems.
\end{textblock}

% PRESENT PROBLEM
\begin{textblock}{34}(0,30)
\HEAD{What problems does it solve?}

Interaction between optional language features won't compromise
type soundness.

\begin{CODE}
\def\INDENT{~~~~~~~~~~~~~}
\{-\# LANGUAGE RankNTypes,\\
\INDENT SystemF,\\
\INDENT RecordSubtyping \#-\}\\
\end{CODE}
\end{textblock}

% FUTURE PROBLEM
\begin{textblock}{30}(0,44)
It provides a theoretic foundation for future library-based
pluggable type systems.
\end{textblock}

% HOW DOES IT WORK
\begin{textblock}{50}(40,19)
\HEAD{How does it work?}

A system of pluggable ideals must make the following
correspondence explicit.
%
Typing terms with rules from multiple systems will amount to
writing proofs with a larger collection of lemmas.

\bigskip
{
\def\>{\hspace{2cm}}
\renewcommand\arraystretch{1.5}
\begin{tabular}{l@{\hskip 5cm}l}
\hline
Syntactic object &
Semantic object
\\[0.5ex]\hline
Term erasable to $\lambda$ &
Value in Scott domain $V\simeq B+(V\rightarrow V)$
\\
\>$\lambda x:\mathrm{Nat}.~x$ &
\> Identity function on $V$
\\
Type &
Ideal, i.~e., nonempty Scott-closed subset of $V$
\\
\>$\mathrm{Nat}\rightarrow\mathrm{Int}$ &
\>$\{f\in V\rightarrow V\ |\ f(\mathbb N_\bot)\subseteq\mathbb Z_\bot\}$
\\
Judgement &
Statement
\\
\>$t:T$ &
\>The value denoted by $t$ belongs to $T$.
\\
Typing rule&
Lemma
\\
\>
\begin{minipage}{10cm}
\[
\frac
{t:S~~~~~~S<:T}
{t:T}
\]
\end{minipage} &
\>
\pbox{40cm}{%
Let $v\in V$ be the value denoted by $t$.\\
If $v\in S$ and $S\subseteq T$, then $v\in T$.
}
\\
Typing derivation &
Proof of the final conclusion
\\[0.5ex]
\hline
\end{tabular}
}
\medskip

\end{textblock}

% HOW APPLICABLE IS IT?
\begin{textblock}{50}(40,59)
\HEAD{How applicable is it?}

Pluggable ideals impose these requirements:
\begin{itemize}
\renewcommand{\labelitemi}{\raisebox{0.4ex}{\FONTSIZE{24}$\bigcirc$}}
\itemindent=1em
\let\olditem\item
\def\item{\olditem~~}
\item Runtime system should be modeled by the Scott domain.
\item Soundness proof should match the correspondence table.
\item All types have to be ideals.
\end{itemize}
The requirements are not hard to satisfy. The Scott domain can
model everything encoded in lambda calculus. Traditional
soundness proofs via denotational semantics fit the
correspondence table. The ideal model can express subtyping,
recursive types, intersection types and more.
\end{textblock}

\end{document}
