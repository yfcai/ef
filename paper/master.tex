\documentclass{amsart}
\usepackage[foot]{amsaddr}
\usepackage{bcprules,url,verbatim,multicol,enumerate}

\let\phi=\varphi % default phi looks like empty set
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}

\input{macros.tex}

\def\CT0{$\text{CT}_0$}

\title[The MPS model of possibly negative algebraic data types]
{The MacQueen-Plotkin-Sethi model of
\\
possibly negative algebraic data types}


\def\thingsExpressibleInMpsModel{%
subtyping, universal types, union and intersection types,
recursive types, dependent types, and higher kinds%
}


\begin{document}

\begin{samepage}

\maketitle

\newskip\shrunken
\shrunken=-0.5cm plus 20cm minus 20cm

\begin{table}[h]
\caption{Correspondence between syntactic and semantic objects}
\label{corres}
\end{table}
\vskip\shrunken
% ...
\def\miniwidth{0.4\textwidth}
\renewcommand\arraystretch{1.5}
\begin{tabular}{ll}
\hline Syntactic object \hspace{1cm}\null& Semantic object \\


\hline Term & Value \\


\indent\texttt{plus 3 5} & \indent the number $8$ \\

\indent$\Abs x x$ & \indent identity function on $V$\\

\indent$\Abs f (\Abs x f~(x~x))~(\Abs x f~(x~x))$
&\indent
\begin{minipage}[t]{\miniwidth}\raggedright
the function mapping each $f\in V\R V$ to its least
fixed point, and each $v\notin V\R V$ to~$\Wrong$
\end{minipage}
\vspace{1ex}
\\


\hline Type expression & Type \\


\indent\texttt{Nat} & \indent$\B N_\bot = \{\bot,0,1,2,\ldots\}$ \\

\indent\texttt{Int} & \indent$\B Z_\bot = \{\bot, 0, 1, -1, 2, -2, \ldots\}$\\

\indent$\texttt{Nat}\R\texttt{Int}$ & \indent$\{f\in V\R V \Or f(\B N_\bot)\subseteq \B Z_\bot\}$ \\

\indent$\All\alpha\alpha\R\alpha$ & \indent$\bigcap_{T\in\Type}\{f\in V\R V \Or f(T) \subseteq T\}$ \\

\indent \texttt{Bot} & \indent $\{\bot\}$ \\

\indent \texttt{Top} & \indent $V-\{\Wrong\}$ \\


\hline Judgement & Statement \\


\indent\texttt{plus 3 5} : \texttt{Nat} & \indent$8\in\B N_\bot$ \\

\indent $x:\texttt{Nat}\VST x:\texttt{Nat}$ & \indent
\begin{minipage}[t]{\miniwidth}
If $\rho(x)\in\B N_\bot$, then $\rho(x)\in\B N_\bot$
\end{minipage}\\

\indent
\begin{minipage}[t]{\miniwidth}
$\alpha ; \beta\in[\texttt{Bot},\alpha]\VSub
% $\\\null\hspace{2em}$
\beta\le\beta\R\alpha$
\end{minipage}
&
\indent
\begin{minipage}[t]{\miniwidth}\raggedright
For all $T_\alpha\in\Type$,\\
for all $T_\beta\in\Type$ with
$\{\bot\}\subseteq T_\beta\subseteq T_\alpha$,
we have
$T_\beta\subseteq\{f\in V\R V \Or f(T_\beta)\subseteq\B T_\alpha\}$
(It is a false statement.)
\end{minipage}
\vspace{1ex}
\\


\hline Typing derivation rule & Theorem \\


\begin{minipage}[t]{\miniwidth}\raggedright
\[\frac{
s:\texttt{Nat}\R\texttt{Int}\qquad
t:\texttt{Nat}
}{s~t:\texttt{Int}}\]
\end{minipage}
&
\indent
\begin{minipage}[t]{\miniwidth}\raggedright
If the term $s$ denotes $f\in\{g\Or g(\B N_\bot)\subseteq \B
Z_\bot\}$ and\\
$t$ denotes $v\in \B N_\bot$, then the denotation $f(v)$ of
the application $s~t$ belongs to $\B Z_\bot$
\end{minipage}
\vspace{1ex}
\end{tabular}

\end{samepage}

\section{Pros and cons}

Bracha (Pluggable type systems) recommends making the type system
of a language optional and independent of the language's runtime
behavior. Doing so confers several benefits.
\begin{enumerate}
\item A useful program can be executed even if it has no type.
\item Type systems can evolve faster than the language itself.
\item Type inference can be made optional as well, so that the
expressiveness of the type system is not bounded by the power of
the inference algorithm.
\end{enumerate}
We demonstrate the technique of denotational pluggable types for
purely functional languages. It achieves all of the above and
more:
\begin{enumerate}\setcounter{enumi}3
\item Several type systems can be used together. If each
subsystem satisfies strong type soundness, then their composite
enjoys strong type soundness as well; the composite type system
would never erroneously accept programs with runtime type errors.
\item Types defined in different subsystems can interact with
each other. It is possible to call library functions defined
in a different type system.
\end{enumerate}
The technique is applicable to a wide variety of type systems. It
gives straightforward interpretations to \thingsExpressibleInMpsModel.

The simplicity comes at a cost: There is a slight restriction on
what a type can be. Say a program $f$ approximates the program
$g$ if $f$ terminates on fewer inputs than $g$ but otherwise
behaves just like $g$. Every type $\tau$ must satisfy the
following conditions:
\begin{itemize}
\item The program \texttt{1 + true} does not have type $\tau$.
\item If $g$ has type $\tau$ and $f$ approximates $g$, then $f$
has type $\tau$.
\item If every program $f$ approximating $g$ has type $\tau$,
then $g$ has type $\tau$.
\end{itemize}
In particular, types cannot separate terminating programs from
nonterminating ones.

The technique guarantees nothing about the type checker's
performance; it may even run forever. Writing a nonterminating
type checker is as easy as writing a nonterminating program in
Java.

\section{Background}

A runtime type error occurs when a value is used in an unintended
way; examples include adding an integer and a truth value,
dereferencing a non-pointer, and calling a non-function. A type
system is \emph{sound} if no well-typed program encounters
runtime type errors during execution. Soundness is one of the
most important design goals of type systems.

There are several methods to prove a type system sound. We will
discuss two: the syntactic approach, and the domain-theoretic
approach.

\Par{The syntactic approach}

It is the current standard framework for soundness proofs.
\begin{enumerate}
\item Capture the runtime behavior of the language in a
small-step semantics such that terms with runtime type errors are
\emph{stuck}: Neither are they values, nor can they reduce to
other terms.
\item Demonstrate \emph{progress}: A well-typed term is either a
value or reduces to something else.
\item Demonstrate \emph{preservation}: If a term has type $\tau$
then it continues to have type $\tau$ after one reduction.
\end{enumerate}
Together, progress and preservation imply that well-typed terms
never get stuck, and thus cannot experience runtime type errors.

In most circumstances, we can ``append'' to a syntactic soundness
proof to accommodate new runtime behaviors without modifying
existing arguments. But we cannot take two systems proven sound
by the syntactic approach, take the union of their typing rules,
and expect soundness to hold for the result. The two syntactic
soundness proofs gave us progress and preservation for terms
typed purely with rules in one system; they say nothing about
terms typed with a mixture of rules from both systems.

\Par{The domain-theoretic approach}

\begin{enumerate}
\item Capture the runtime behavior of the language in a domain
equation.
\item Define types as certain sets of values in the semantic
domain. Designate a special value $\Wrong$ for runtime type
errors, and make sure it is not a member of any type.
\item Construct an interpretation from terms to values in the
semantic domain. Show that if a term $t$ has type $\tau$, then
$t$ interprets to a member of $\tau$.
\end{enumerate}
Since no type contains $\Wrong$, well-typed programs do not
denote $\Wrong$, and their evaluation may not encounter runtime
type errors.

A domain-theoretic soundness proof is not extensible with new
runtime behaviors. Adding mutation to a purely functional
language, for example, requires a completely new domain equation.
The old arguments have to be rewritten, because their
foundation---the old domain equation---has become obsolete.

However, if we extend the type system without modifying the
runtime behavior, then we can keep interpreting terms into the
old semantic domain. If the new typing rules are sound on their
own, then they already meet the expectation of the old soundness
proof, namely that they assign type $\tau$ only to terms
interpreting to a member of $\tau$. In this way, the old proof
carries over even to terms typed with a mixture of old and new
rules, and type soundness continues to hold.

If types are pluggable, then the language's runtime behavior has
to stay constant in all possible type systems. In this situation,
a domain-theoretic type soundness proof is more extensible than a
syntactic proof.


\section{Roadmap}

To achieve safely pluggable types, we exploit the extensibility
of domain-theoretic type soundness proofs when the runtime system
never changes. These are the steps:
\begin{enumerate}
\item Choose a semantic domain. For purely functional languages,
a domain for untyped lambda calculus suffices.
\item Choose a theory of types for the semantic domain. We employ
the ideal model by MacQueen, Plotkin and Sethi. It can easily
express \thingsExpressibleInMpsModel.
\item Develop type systems such that each typing rule corresponds
to a true statement in the theory of types. This property tends
to be a part of the usual domain-theoretic soundness proof; it
often incurs no effort beyond what is required to write the
soundness proof in the first place.
\end{enumerate}
Thus typing rules become lemmas, judgements become statements,
and terms with type annotations become proofs. Typing terms with
a mixture of type systems is no more than writing proofs with a
larger collection of lemmas.

The next section discusses domains and the MacQueen-Plotkin-Sethi
model of types on a high level. We will only disclose the
technical details absolutely essential for understanding
pluggable types.

The section after that describes the plugin architecture.

The section after that describes pluggable simply typed lambda
calculus as a warm-up example.

The section after that describes CT1, a pluggable type system
that supports unboxed impredicative polymorphism.

The section after that describes how to make System~F pluggable.
Using System~F and CT1 together, we make the inference of type
arguments optional.

The section after that adds subtyping and whatever else comes to
my mind.


\section{MacQueen-Plotkin-Sethi model of types}

Outline
\begin{enumerate}
\item domain equation
\item interpretation of untyped lambda calc into the domain
\item reflexive transitive antisymmetric ordering $\Sub$
\item topology, continuous functions, compact elements
\item rank of elements; every compact element has a finite rank
\item types
\item proximity between types
\item contractive, nonexpansive
\item type constructors: finite union, arbitrary intersection,
recursive
\item btw, existence of unique fixed point means that initial
algebras are final coalgebras whose object is the fixed point and
whose morphism is id. which means lists \emph{are} streams, period.
\end{enumerate}


\section{Architecture (what's a more folksy title?)}

We have learnt the notion of types, the nature of function types,
and the construction of recursive types. This section describes,
at a high level, how we use such knowledge to make type systems
pluggable.


\begin{enumerate}
\item Untyped $\lambda$ is a powerful runtime system, enjoys
natural and local encoding of many features. Untyped $\lambda$ is
our core language.

\item Pluggable type systems may declare extensions to term
syntax, but the runtime understands none of them. Each syntax
extension must be able to erase to an untyped lambda term, and so
it may be considered an optional type annotation.

\item Syntax of types is left open for type system plugins. Care
must be taken in introducing a new type expression that it
interprets to an actual type, not just some value set. Useful
type constructors are: finite union, arbitrary intersection,
arbitrary supremum, function type, recursive type. Useful encoded
types are: records, variants, existential types.

\item Type system plugins produce judgements. One may regard
judgements as abbreviations of well-formed formulas in
Zermelo-Fraenkel set theory with the axiom of choice. Judgements
include, but are not limited to, typing judgements $t:\tau$ for
closed terms $t$ and closed type expressions $\tau$, which
expands to ``the value denoted by $t$ is a member of the type
denoted by $\tau$''.

\item A typing rule consists of zero or more antecedents, zero or
more side conditions, and one conclusion. The antecedents are
judgements, the side conditions are well-formed formulas, and the
conclusion is a judgement. A typing rule interprets to the
statement ``If all antecedents and side conditions are true, then
the conclusion is true.'' A typing rule is sound if its
interpretation is true.

\item A typing derivation is a finite tree build from instances
of typing rules in the manner of natural deduction, where all
antecedents of each rule instance coincide with the conclusions
of rule instances immediately above it, and all side conditions
are true. If all typing rules involved are sound, then each rule
instance corresponds to a true implication, and the typing
derivation corresponds to a proof of the ultimate conclusion by
repeated application of modus ponens.

\item Each pluggable type system is a collection of typing rules.
A type system is sound if all rules are sound. We mix type
systems together by taking the union of their typing rules. Sound
systems have sound rules and produce a sound mixture.
\end{enumerate}




\section{Warm-up example: simply typed lambda calculus}

We're reading MPS's interpretation section to get some ideas
about how to write this section.



\section{Constrained type system version 1}



\section{Parametric types}

Can refine ``up to termination'' relation in ``fast and loose
reasoning'' to the binary consistency relation. Free theorems
should hold. Parametric types are not universal types.


\input{appendix.tex}
\end{document}
