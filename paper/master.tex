\documentclass{amsart}
\usepackage[foot]{amsaddr}
\usepackage{bcprules,url}

% TODO: reformat bio-data as PLDI requires
\title
{Impredicative Polymorphism\break
for Shakespearean Monkeys}
\author{Yufei Cai}
\address{{\rm
Philipps-Universit\"at Marburg\\
\url{cai@mathematik.uni-marburg.de}\\
05D06 Mehrzweckgeb\"aude, Hans-Meerwein Str., 35039 Marburg, Germany}}

\let\phi=\varphi % default phi looks like empty set
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}

\input{macros.tex}
\begin{document}
\maketitle

\subsection{Problem statement}

The problem is, first-class polymorphism has hardly any presence
in everyday computing.

First-class polymorphism is a wonderful feature for statically
typed functional languages. It refers to the ability to not only
define polymorphic functions, but also take them as arguments and
use them polymorphically in the body of any definition. With
first-class polymorphism, a library function can sort arrays of
different things with a user-defined sorting algorithm. Less
mundane applications include B\"ohm-Berarducci encoding of
algebraic data types~\cite{Boehm85}, scrap-your-boilerplate
pattern~\cite{Laemmel03}, foldable higher-order abstract
syntax~\cite{Washburn03}, and ST monad~\cite{Launchbury94}. Those
applications were discovered despite this age's far-from-perfect
support for first-class polymorphism. One may wonder how much
more would be found expressible if first-class polymorphism were
effortless to use.

A type system with first-class polymorphism would become
practical sooner if it were easy to use and easy to implement. A
perspicuous type safety proof could help as well. Such a type
system is my goal.

TODO: short summary of what is meant by ``ease of use'' and
``ease of implementation''.

\subsection{Historical background}


\input{bib.tex}\end{document}
