\documentclass{amsart}
\usepackage{bcprules,url,enumerate}
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[subsection]{Definition}

\def\thesubsection{\arabic{subsection}}

\input{../paper/macros.tex}
\begin{document}

\subsection{Syntax}
\begin{syntax}
\mbox{type}\\
\sigma, \tau
&::=& \iota_0 \Or \iota_1 \Or \cdots &\mbox{base type}\\
&|& \alpha \Or \beta \Or \cdots & \mbox{type variable} \\
&|& \tau \rightarrow \tau & \mbox{function type} \\
&|& \All\alpha\tau & \mbox{universal type} \\
&|& \Ex\alpha\tau & \mbox{existential type}
\\
\\
\mbox{term}\\
s, t & ::= & x & \mbox{variable} \\
& | & \Abs{x:\tau}t  & \mbox{lambda abstraction} \\
& | & t~t & \mbox{function application} \\
& | & \mbox{primitives}
\end{syntax}

\subsection{Domain}
The domain of values $V$ is the solution to the following domain
equations.
\begin{align*}
V &= F + B_0 + B_1 + \cdots + \{\Wrong\}
  &&\mbox{disjoint sum of domains}\\
F &= V \R V &&\mbox{continuous functions from $V$ to $V$}
\end{align*}
Here and elsewhere, we omit all domain-theoretic details, such as
the fact that domain equations are solved only up to isomorphism,
and that disjoint sum with a bottomless set (e.~g., $\{\Wrong\}$)
must be encoded as smash sum with a flat domain. To lighten
notational and conceptual burden, let us treat $B_i$, $F$ and
$\{\Wrong\}$ as if they were actual subsets of $V$.

\subsection{Wrongless downsets}
\label{wrongless}
(Note to self: If downward closedness turned out to be
unnecessary, write a variant where types simply denote subsets of
values excluding $\Wrong$.) Closed types denote wrongless
downsets. A subset $S$ of the domain $V$ is \emph{downward
closed} if for all $u\in S$, all elements smaller than $u$ in $V$
are contained in $S$. A subset of $V$ is a \emph{wrongless
downset} if it is downward closed and does not contain $\Wrong$.
Write $\Down$ for the family of all wrongless downsets.
$\Down$~is never empty; $\{\bot\}$ is a wrongless downset, for
example.

\subsection{Functionality of wrongless downsets}
\label{functionality}
The functionality of wrongless down\-sets is the trivial
generalization of Milner's adaptation of Scott's notion of
functionality~\cite{Milner78}.

Let $S_0$ and $S_1$ be wrongless downsets. The
\emph{functionality} from $S_0$ to $S_1$, writ $S_0\RR S_1$, is
the set of functions that always map values in $S_0$ to values in
$S_1$, but can map values outside $S_0$ to anything in $V$.
\[
S_0 \RR S_1 =
\{\bot\}\cup\{f\in F \Or f(S_0) \subseteq S_1\}.
\]
Function types denote functionalities. A functionality is defined
to be inclusive enough to contain all polymorphic functions
capable of ``instantiating'' to the desired function type.

\subsection{Closure properties of wrongless downsets}
The functionality between two wrongless downsets is a wrongless
downset. The intersection of any nonempty family of wrongless
downsets is a wrongless downset. The union of any nonempty family
of wrongless downsets is a wrongless downset.

\subsection{Denotation of types}
\label{denotation-types}
Closed types denote wrongless downsets. Open types denote a
function mapping each environment of wrongless downsets to a
wrongless downset.

Upper case $\Env$ refers to an environment mapping type variables
to wrongless downsets; lower case $\env$ will refer to an environment
mapping term variables to values in \S\ref{denotation-terms}.
\begin{align*}
\Sem{\iota_i}~\Env &= \{\bot\}\cup B_i\\
\Sem{\alpha}~\Env &= \Env(\alpha)\\
\Sem{\sigma\R\tau}~\Env&=
  (\Sem{\sigma}~\Env)\RR(\Sem{\tau}~\Env)\\
\Sem{\All\alpha\tau}~\Env&=
  {\textstyle\bigcap_{S\in\Down}}
  \left(\Sem\tau~(\Update\Env{\alpha\mapsto S})\right)\\
\Sem{\Ex\alpha\tau}~\Env&=
  {\textstyle\bigcup_{S\in\Down}}
  \left(\Sem\tau~(\Update\Env{\alpha\mapsto S})\right)
\end{align*}
The reader may verify that the right hand side of this definition
is always a wrongless downset. The family $\Down$ of all
wrongless downsets is defined in \S\ref{wrongless}. The
functionality construction $\RR$ is described in
\S\ref{functionality}. Examples:
\begin{align*}
\Sem{\All\alpha\alpha}~\Env&=\{\bot\}\\
\Sem{\Ex\alpha\alpha}~\Env&=V-\{\Wrong\}
\end{align*}

\subsection{Equivalence of types}
Set-theoretic equality of the denotation of types induce an
equivalence relation on types. Examples:
\begin{enumerate}[(i)]
\item
$\Sem{\All\alpha\sigma\R\tau}=\Sem{\sigma\R(\All\alpha\tau)}$
where $\alpha\notin\FTV(\sigma)$,
\item
$\Sem{\Ex\alpha\sigma\R\tau}=\Sem{\sigma\R(\Ex\alpha\tau)}$
where $\alpha\notin\FTV(\sigma)$,
\item
$\Sem{\All\alpha\sigma\R\tau}=\Sem{(\Ex\alpha\sigma)\R\tau}$
where $\alpha\notin\FTV(\tau)$,
\item
$\Sem{\Ex\alpha\sigma\R\tau}=\Sem{(\All\alpha\sigma)\R\tau}$
where $\alpha\notin\FTV(\tau)$,
\item
$\Sem{\All\alpha\Ex\beta\tau}=\Sem{\Ex\beta\All\alpha\tau}$.
\end{enumerate}
Types on both sides of (i) or (ii) are equisatisfiable as
propositions of intuitionistic logic. Types on both sides of
(iii) or (iv) are equisatisfiable as propositions of classical
logic. The equivalence expressed by (v) is seen in neither.


\subsection{Denotation of terms}
\label{denotation-terms}
Terms denote values as if they were untyped. Primitives may
denote anything in $V$, as long as the value of each primitive
operator satisfies strong type soundness.

Upper case $\Env$ is type-level environment
(\S\ref{denotation-types}). Lower case $\env$ refers to an
environment mapping term variables to values in $V$.
\begin{align*}
\Sem{x}~\env&=\env(x)\\
\Sem{\Abs{x:\tau}t}~\env&=
  f\in F\text{\quad such that\quad}
  f(v)=\Sem{t}~(\Update\env{x\mapsto v})
\\
\Sem{s~t}~\env&=
\begin{cases}
f(\Sem{t}~\env)&\text{if }(\Sem{s}~\env)=f\in F
\\
\bot&\text{if }(\Sem{s}~\env)=\bot
\\
\Wrong&\text{if }(\Sem{s}~\env)\notin F\cup\{\bot\}
\end{cases}
\\
\Sem{\mathrm{primitive}}~\env&=\cdots
\end{align*}


\subsection{Syntax of subtype judgements}

We define a syntactic relation $\Sub$ on types. We call it the
\emph{subtype} relation because for closed types $\sigma$,
$\tau$, the relation $\sigma \Sub \tau$ implies that the
wrongless downset denoted by $\sigma$ is a \emph{subset} of the
wrongless downset denoted by $\tau$ (\S\ref{subsound}).

The symbol $\Sub$ stands for the partial order between values of
a domain in literature about domain theory. At the same time,
$\Sub$ stands for the ``more general'' partial order between
types in literature about parametric polymorphism. Our use of
$\Sub$ follows the latter.

\begin{syntax}
\mbox{list of type variables}\\
A,E
&::=& \emptyset \\
&|& \alpha,A
\\
\\
\mbox{list of constraints}\\
C
&::=& \emptyset \\
&|& \sigma \Sub \tau, C
\\
\\
\mbox{subtype judgement}
&::=&A;E\vdash C
\end{syntax}

In a judgement $A;E\vdash C$, the type variables in $A$ represent
wrongless downsets that can be chosen later so that constraints
in $C$ hold; they are \emph{accommodating}. The type variables in
$E$ represent demands that the constraints in $C$ must be
satisfiable whichever downsets are chosen for them; they are
\emph{exigent}.

\subsection{Derivation of subtype judgements}~

\infrule[S-Refl]
{}
{A;E \vdash \tau_0\Sub\tau_0,\tau_1\Sub\tau_1,
\ldots,\tau_n\Sub\tau_n}

\infrule[S-Arrow]
{A;E\vdash\tau_0\Sub\sigma_0,\sigma_1\Sub\tau_1,C}
{\Delta\vdash\sigma_0\R\sigma_1\Sub\tau_0\R\tau_1,C}

\infrule[S-Loner]
{\alpha\notin A\cup E\cup\FTV(C)
\andalso
A;E\vdash
\{ \sigma_i\Sub\tau_j \Or 0 \le i \le m, 0 \le j \le n \}
\cup C
}{
\alpha,A;E \vdash
\sigma_0\Sub\alpha,\ldots,\sigma_m\Sub\alpha,
\alpha\Sub\tau_0,\ldots,\alpha\Sub\tau_n,C
}

\infrule[S-Al]
{\alpha\notin A\cup E
\andalso
\alpha,A;E\vdash\sigma\Sub\tau,C}
{A;E\vdash(\All\alpha\sigma)\Sub\tau,C}

\infrule[S-Ar]
{\alpha\notin A\cup E
\andalso
\alpha,A;E\vdash\sigma\Sub\tau,C}
{A;E\vdash\sigma\Sub(\Ex\alpha\tau),C}

\infrule[S-El]
{\alpha\notin A\cup E
\andalso
A;\alpha,E\vdash\sigma\Sub\tau,C}
{A;E\vdash(\Ex\alpha\sigma)\Sub\tau,C}

\infrule[S-Er]
{\alpha\notin A\cup E
\andalso
A;\alpha,E\vdash\sigma\Sub\tau,C}
{A;E\vdash\sigma\Sub(\All\alpha\tau),C}

\subsection{Soundness of subtyping}
\label{subsound}



\input{bib.tex}\end{document}
