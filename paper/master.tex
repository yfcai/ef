% latex
\documentclass{amsart}
\usepackage{bcprules}
\title{
The Classical Call/CC Calculus
\penalty-20000
and Impredicative Type Inference
}

\swapnumbers
\newtheorem{lemma}[subsection]{Lemma}

\begin{document}
\newcommand{\nc}{\newcommand}
\newcommand{\DotExpr}[2]{#1 #2.\ }
\nc\Abs   {\DotExpr\lambda}
\nc\All   {\DotExpr\forall}
\nc\CallCC{\operatorname{call/cc}}
\nc\Cps   {\operatorname{cps}}
\nc\Dn [1]{(#1 \R \bot) \R \bot}
\nc\Ex    {\DotExpr\exists}
\nc\FV    {\operatorname{FV}}
\nc\Mgs   {\operatorname{mgs}}
\nc\Or    {\ | \ }
\nc\Prune {\operatorname{prune}}
\nc\Recall{\DotExpr\Xi} % looks like âˆƒ
\nc\Redo  {\operatorname{redo}}
\nc\Tabs  {\DotExpr\Lambda}
\nc\R     {\rightarrow}
\nc\Undo  {\operatorname{undo}}
\nc\Unify {\operatorname{unify}}

\maketitle
\tableofcontents

\section{Classical F}

\subsection{Grammar of classical F}

\nc\Ftype{
\tau & ::= & \alpha & \mbox{type variable} \\
&\Or& \tau \rightarrow \tau & \mbox{function type} \\
&\Or& \All\alpha\tau & \mbox{universal type} \\
}

\nc\CFtype{
\Ftype
&\Or& \Ex\alpha\tau & \mbox{existential type} \\
}

\nc\CFterm{
t & ::= & x & \mbox{variables} \\
&\Or& \Abs{x:\tau}t  & \mbox{lambda abstraction} \\
&\Or& \ t~t & \mbox{function application} \\
}

\nc\SelectiveTypeAmnesia{
&\Or& t~\{\Ex\alpha\tau\} & \mbox{selective type amnesia} \\
}

\nc\TypingContexts{
\Gamma & ::= & \Gamma, x : \tau & \mbox{term variable binding}\\
&\Or& \Gamma, \alpha& \mbox{type variable binding} \\
&\Or& \epsilon & \mbox{empty context}\\ \\
}

\[
\begin{array}{lclr}
% types
\CFtype
\\
% terms
\CFterm
&\Or& \Tabs\alpha t & \mbox{cosmetic type abstraction} \\
\SelectiveTypeAmnesia
\\
% contexts
\TypingContexts
\end{array}
\]

\subsection{Typing of classical F}
~

\nc\Tautology{
\infrule[Taut]
{x : \tau \in \Gamma}
{\Gamma \vdash x : \tau}
}

\nc\UniversalIntroduction{
\infrule[$\forall$I]
{\Gamma,\alpha \vdash t:\tau
  \andalso \alpha \notin \Gamma}
{\Gamma \vdash (\Tabs\alpha t) : \All\alpha\tau}
}

\nc\ExistentialIntroduction{
\infrule[$\exists$I]
{\Gamma \vdash t : \tau[\alpha\mapsto\sigma]}
{\Gamma \vdash t~\{\Ex\alpha\tau\} : \Ex\alpha\tau}
}

\nc\UniversalNegation{
\infrule[$\neg\forall$]
{\Gamma \vdash t : (\All\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \Ex\alpha \sigma \R \tau}
}

\nc\ExistentialNegation{
\infrule[$\neg\exists$]
{\Gamma \vdash t : (\Ex\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \All\alpha \sigma \R \tau}
}

\nc\SuperIntroduction{
\infrule[$\R\forall$I]
{\Gamma, A, x:\sigma \vdash t : \tau
  \andalso A = \FV(\sigma) - \Gamma}
{\Gamma \vdash (\Abs{x:\sigma}t) : \All A{\sigma\R\tau}}
}

\nc\SuperElimination{
\infrule[$\R\forall\exists$E]
{\Gamma \vdash s : \All{A_s} \Ex{E_s} \sigma_s \R \tau
  \andalso \Gamma \vdash t : \All{A_t} \Ex{E_t} \sigma_t \\
  A = A_s \uplus A_t \andalso E = E_s \uplus E_t \\
  \Unify(A, E, \sigma_s, \sigma_t) \downarrow \Mgs}
{\Gamma \vdash s~t : \Prune(\All A \Ex E \Mgs(\tau))}
}

\Tautology

\UniversalNegation

\ExistentialNegation

\SuperIntroduction

\SuperElimination

Pruning removes redundant quantifiers, i.~e., those who bind
names that never occur free in their scopes. Unification is
discussed in section~\ref{sec:unify}.

\UniversalIntroduction

\ExistentialIntroduction

\section{Classical call/cc calculus}

\subsection{Grammar of classical call/cc calculus}

\nc\Fterm{
\CFterm
&\Or& \Tabs\alpha t & \mbox{type abstraction} \\
&\Or& t~[\tau] & \mbox{type application} \\
}

\[
\begin{array}{lclr}
% types
\Ftype
&\Or& \Ex\alpha\tau & \mbox{existential type} \\
&\Or& \bot & \mbox{result type of continuations} \\
\\
% terms
\Fterm
\SelectiveTypeAmnesia
&\Or& \Recall\alpha t & \mbox{deferred type remembrance} \\
&\Or& \CallCC~t & \mbox{call with current continuation} \\
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of classical call/cc calculus}
~

\nc\FRules{
\Tautology
%
\infrule[$\R$I]
{\Gamma,x:\sigma \vdash t : \tau}
{\Gamma \vdash (\Abs{x:\sigma}t) : \sigma\R\tau}
%
\infrule[$\R$E]
{\Gamma\vdash s:\sigma\R\tau   \andalso   \Gamma\vdash t:\sigma}
{\Gamma\vdash s~t:\tau}
%
\UniversalIntroduction
%
\infrule[$\forall$E]
{\Gamma \vdash t : \All\alpha\tau}
{\Gamma \vdash t~[\sigma] : \tau[\alpha\mapsto\sigma]}
}

\nc\ExistentialElimination{
\infrule[$\exists$E]
{\Gamma,\alpha \vdash t:\sigma\R\tau
  \andalso \alpha \notin \Gamma
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash (\Recall\alpha t):(\Ex\alpha\sigma)\R\tau}
}

\nc\DoubleNegationElimination{
\infrule[$\neg\neg$E]
{\Gamma \vdash t : ((\tau\R\bot)\R\bot)\R\bot}
{\Gamma \vdash \CallCC~t : \tau}
}

\FRules

\ExistentialIntroduction

\ExistentialElimination

\DoubleNegationElimination

\section{System F}

\subsection{Grammar of system F}

\[
\begin{array}{lclr}
\Ftype
&\Or& \bot & \mbox{bottom type} \\
\\
\Fterm
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of system F}
~

\FRules

\subsection{Embedding classical call/cc calculus in system F}

Due to Curry-Howard correspondence, the embedding of classical
call/cc calculus in system F can be viewed from either a
logical or a programming perspective.
\begin{itemize}
\item From the logical point of view, the embedding is an
instance of Kolmogorov's negative translation from classical
logic to intuitionistic logic.
\item From the programming point of view, the embedding is a
continuation-passing-style transformation that gets rid of
$\CallCC$ and existential types.
\end{itemize}
If $\tau$ is a type in classical call/cc calculus, then $\tau^K$
shall be the corresponding type in system F. It is a similar
correspondence between contexts $\Gamma$ and $\Gamma^K$, or
between terms $t$ and $t^K$. The aforementioned embedding
transforms typing judgements in the classical calculus to typing
judgements in F. We shall call it ``$\Cps$''.

\def\INDENT{\hspace{3em}}

\begin{align*}
\alpha^K & =
  \Dn\alpha
  \\
(\sigma \R \tau)^K & =
  \Dn{(\sigma^K \R \tau^K)}
  \\
(\All\alpha\tau)^K & =
  \Dn{(\All\alpha\tau^K)}
  \\
(\Ex\alpha\tau)^K & =
  (\All\alpha \tau^K \R \bot) \R \bot
  \\
\bot^K & =
  \Dn\bot
\end{align*}

\begin{align*}
(\Gamma, x:\tau)^K & =
  \Gamma^K, x:\tau^K
  \\
(\Gamma, \alpha)^K & =
  \Gamma^K, \alpha
  \\
\epsilon^K & =
  \epsilon
\end{align*}

% cps: tautology
\begin{align*}
\Cps(\Gamma \vdash x : \tau) & =
  \Gamma^K \vdash x : \tau^K
\end{align*}

% cps: implication introduction
\begin{align*}
\Cps(\Gamma \vdash (\Abs{x:\sigma}t) : \sigma \R \tau) & =
  \Gamma^K \vdash (\Abs{x:\sigma}t)^K : \Dn{(\sigma^K \R \tau^K)} &
  \mbox{where}
  \\
\Gamma^K,x:\sigma^K \vdash t^K : \tau^K & =
  \Cps(\Gamma,x:\sigma \vdash t : \tau)
  \\
(\Abs{x:\sigma}t)^K & =
  \Abs{c : ((\sigma^K \R \tau^K) \R \bot)}c~(\Abs{x : \sigma^K} t^K)
\end{align*}

% cps: implication elimination
\begin{align*}
\Cps(\Gamma \vdash s~t : \tau) & =
  \Gamma^K \vdash (s~t)^K : \tau^K
  & \mbox{where}
  \\
\Gamma^K \vdash s^K : \Dn{(\sigma^K \R \tau^K)} & =
  \Cps(\Gamma \vdash s : \sigma \R \tau)
  \\
\Gamma^K \vdash t^K : \sigma^K & =
  \Cps(\Gamma \vdash t : \sigma)
  \\
\rho \R \bot & = \tau^K
  \\
(s~t)^K & =
  \Abs{c : \rho} s^K~(\Abs{f : \sigma^K \R \rho \R \bot} \\
  &\INDENT t^K~(\Abs{x : \sigma^K} f~x~c))
\end{align*}

% cps: universal introduction
\begin{align*}
\Cps(\Gamma \vdash (\Tabs\alpha t) : \All\alpha \tau) & =
  \Gamma^K \vdash (\Tabs\alpha t)^K : \Dn{(\All\alpha \tau^K)}
  & \mbox{where}
  \\
\Gamma^K,\alpha \vdash t^K : \tau^K & =
  \Cps(\Gamma,\alpha \vdash t : \tau)
  \\
(\Tabs\alpha t)^K & =
  \Abs{c : ((\All\alpha \tau^K) \R \bot)}c~(\Tabs\alpha \tau^K)
\end{align*}

% cps: universal elimination
\begin{align*}
\Cps(\Gamma \vdash t~[\sigma] : \tau[\alpha\mapsto\sigma]) & =
  \Gamma^K \vdash (t~[\sigma])^K :
  \Dn{\tau_1}
  & \mbox{where}
  \\
\Gamma^K \vdash t^K : \Dn{(\All\alpha \tau)} & =
  \Cps(\Gamma \vdash t : \All\alpha \tau)
  \\
\rho \R \bot & = \sigma^K
  \\
\tau_1 & = \tau^K[(\Dn\alpha) \mapsto \sigma^K]
  \\
\tau_2 & = \tau^K[\alpha \mapsto \sigma^K]
  \\
(t~[\sigma])^K & =
  \Abs{c : (\tau_1 \R \bot)} t^K~(\Abs{x : (\All\alpha\tau)} \\
  &\INDENT
  c~\Undo_{\alpha,\rho}(x~[\sigma^K], \tau))
\end{align*}

\begin{lemma}
[$\Undo$ and $\Redo$]
\label{lem:undo-redo}
For every type variable $\alpha$ and every type $\sigma$, there
exists a pair of computable functions $\Undo_{\alpha,\sigma}$ and
$\Redo_{\alpha,\sigma}$ such that
\begin{itemize}
\item
whenever
$\Gamma \vdash t : \tau^K[\alpha \mapsto (\sigma\R\bot)]$
we have
\[
\Gamma \vdash \Undo_{\alpha,\sigma}(t,\tau) :
  \tau^K[(\Dn\alpha) \mapsto (\sigma\R\bot)],
\]
\item
whenever
$\Gamma \vdash t' : \tau^K[(\Dn\alpha) \mapsto (\sigma\R\bot)]$
we have
\[
\Gamma \vdash \Redo_{\alpha,\sigma}(t',\tau) :
  \tau^K[\alpha \mapsto (\sigma\R\bot)].
\]
\end{itemize}
\end{lemma}

\begin{proof}
[Proof by induction on $\tau$]
We shall omit the subscripts $\alpha$, $\sigma$ and write simply
$\Undo$, $\Redo$ from now on. For every type $\rho$, write
\begin{align*}
\rho_1 & = \rho^K[(\Dn\alpha)\mapsto(\sigma\R\bot)],\\
\rho_2 & = \rho^K[\alpha\mapsto(\sigma\R\bot)].
\end{align*}

Case $\tau = \alpha$: Brouwer's double negation elimination is
$\Undo$ and double negation introduction is $\Redo$.

Case $\tau = \bot$: The type variable $\alpha$ is not free in
$\tau$. Thus we can set
\begin{align*}
\Undo(t,\bot) & = t, \\
\Redo(t,\bot) & = t.
\end{align*}
\end{proof}

\begin{lemma}
[substitution lemma for Kolmogorov's negative translation]
\label{lem:subst-kolmogorov}
\[
(\tau[\alpha\mapsto\sigma])^K =
\tau^K[(\Dn\alpha) \mapsto \sigma^K].
\]
\end{lemma}

\begin{proof}
[Proof by induction on $\tau$]
\end{proof}

\section{Unification of quantified names}
\label{sec:unify}

\end{document}
