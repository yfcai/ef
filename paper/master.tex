% latex
\documentclass{amsart}
\usepackage{bcprules,url}
\title
[Impredicative type inference]
{
Impredicative type inference
\break
or
\break
partial proof reconstruction \break
for second-order classical logic
}

\let\phi=\varphi % default phi looks like empty set
\allowdisplaybreaks
\swapnumbers
\newtheorem{lemma}[subsection]{Lemma}

\begin{document}
\newcommand{\nc}{\newcommand}
\newcommand{\DotExpr}[2]{#1 #2.\ }
\nc\Abs    {\DotExpr\lambda}
\nc\All    {\DotExpr\forall}
\nc\Allin  {\forall\mathrm{in}}
\nc\Allex  {\forall\mathrm{ex}}
\nc\AppCC  {\mathrm{app/cc}}
\def\Box   {\mathrm{box}}
\nc\Brouwer{\operatorname{Brouwer}}
\nc\CallCC {\mathrm{call/cc}}
\nc\Case   {}
\nc\Cps    {\operatorname{cps}}
\nc\Dn[1]  {(#1 \R \bot) \R \bot}
\nc\Dni    {\mathrm{\neg\neg I}}
\nc\Ex     {\DotExpr\exists}
\nc\Exin   {\exists\mathrm{in}}
\nc\Exex   {\exists\mathrm{ex}}
\nc\FV     {\operatorname{FV}}
\nc\Id     {\mathit{id}}
\nc\Indent {\hspace{3em}}
\nc\Mgs    {\operatorname{mgs}}
\nc\Or     {\ | \ }
\nc\Prune  {\operatorname{prune}}
\nc\Recall {\DotExpr\Xi} % looks like âˆƒ
\nc\Redo   {\operatorname{redo}}
\nc\Tabs   {\DotExpr\Lambda}
\nc\R      {\rightarrow}
\nc\Unbox  {\mathrm{unbox}}
\nc\Undo   {\operatorname{undo}}
\nc\Unify  {\operatorname{unify}}
\maketitle
\tableofcontents

\section{Executive summary}

Existential F is a language with
\begin{itemize}
\item first-class existential types,
\item impredicative polymorphism, and
\item decidable typing of Church-style terms.
\end{itemize}
It bears emphasis that Existential F has more permissive
existential types than the traditional encoding of existentials
in System F. If we think harder, maybe we could come up with an
example of greater practical benefit than moving quantifiers
around.

To show type soundness of Existential F, we embed it in System F.
First we get rid of first-class existential quantifiers by
translating it into Continuation Calculus, a formalization of
second-order classical logic, then we get rid of the trappings of
classical logic, e.~g.\ double negation elimination, via a
continatuation-passing-style transformation into System F. The
said continuation-passing-style transformation is a formalization
of the world's first embedding of classical logic in
intuitionistic logic by Andrey Nikolaevich Kolmogorov.

\section{Existential F}

\subsection{Grammar of Existential F}

\nc\Ftype{
\tau & ::= & \alpha & \mbox{type variable} \\
&\Or& \tau \rightarrow \tau & \mbox{function type} \\
&\Or& \All\alpha\tau & \mbox{universal type} \\
}

\nc\CFtype{
\Ftype
&\Or& \Ex\alpha\tau & \mbox{existential type} \\
}

\nc\CFterm{
t & ::= & x & \mbox{variable} \\
&\Or& \Abs{x:\tau}t  & \mbox{lambda abstraction} \\
&\Or& \ t~t & \mbox{function application} \\
}

\nc\SelectiveTypeAmnesia{
&\Or& t~\{\Ex\alpha\tau\} & \mbox{selective type amnesia} \\
}

\nc\TypingContexts{
\Gamma & ::= & \Gamma, x : \tau & \mbox{term variable binding}\\
&\Or& \Gamma, \alpha& \mbox{type variable binding} \\
&\Or& \epsilon & \mbox{empty context}\\ \\
}

\[
\begin{array}{lclr}
% types
\CFtype
\\
% terms
\CFterm
&\Or& \Tabs\alpha t & \mbox{cosmetic type abstraction} \\
\SelectiveTypeAmnesia
\\
% contexts
\TypingContexts
\end{array}
\]

\subsection{Typing of Existential F}
~

\nc\Tautology{
\infrule[Taut]
{x : \tau \in \Gamma}
{\Gamma \vdash x : \tau}
}

\nc\UniversalIntroduction{
\infrule[$\forall$I]
{\Gamma,\alpha \vdash t:\tau
  \andalso \alpha \notin \Gamma}
{\Gamma \vdash (\Tabs\alpha t) : \All\alpha\tau}
}

\nc\ExistentialIntroduction{
\infrule[$\exists$I]
{\Gamma \vdash t : \tau[\alpha\mapsto\sigma]}
{\Gamma \vdash t~\{\Ex\alpha\tau\} : \Ex\alpha\tau}
}

\nc\UniversalNegation{
\infrule[$\neg\forall$]
{\Gamma \vdash t : (\All\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \Ex\alpha \sigma \R \tau}
}

\nc\ExistentialNegation{
\infrule[$\neg\exists$]
{\Gamma \vdash t : (\Ex\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \All\alpha \sigma \R \tau}
}

\nc\SuperIntroduction{
\infrule[$\R\forall$I]
{\Gamma, A, x:\sigma \vdash t : \tau
  \andalso A = \FV(\sigma) - \Gamma}
{\Gamma \vdash (\Abs{x:\sigma}t) : \All A{\sigma\R\tau}}
}

\nc\SuperElimination{
\infrule[$\R\forall\exists$E]
{\Gamma \vdash s : \All{A_s} \Ex{E_s} \sigma_s \R \tau
  \andalso \Gamma \vdash t : \All{A_t} \Ex{E_t} \sigma_t \\
  A = A_s \uplus A_t \andalso E = E_s \uplus E_t \\
  \Unify(A, E, \sigma_s, \sigma_t) \downarrow \Mgs}
{\Gamma \vdash s~t : \Prune(\All A \Ex E \Mgs(\tau))}
}

\Tautology

\UniversalNegation

\ExistentialNegation

\SuperIntroduction

\SuperElimination

Pruning removes redundant quantifiers, i.~e., those who bind
names that never occur free in their scopes. Unification is
discussed in section~\ref{sec:unify}.

\UniversalIntroduction

\ExistentialIntroduction

\section{Continuation Calculus}

\subsection{Grammar of Continuation Calculus}

\nc\Fterm{
\CFterm
&\Or& \Tabs\alpha t & \mbox{type abstraction} \\
&\Or& t~[\tau] & \mbox{type application} \\
}

\[
\begin{array}{lclr}
% types
\Ftype
&\Or& \bot & \mbox{result type of continuations} \\
\\
% terms
\Fterm
&\Or& \CallCC~t & \mbox{call with current continuation} \\
&\Or& \AppCC~t~t & \mbox{apply with current continuation} \\
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of Continuation Calculus}
~

\nc\UniversalElimination{
\infrule[$\forall$E]
{\Gamma \vdash t : \All\alpha\tau
   \andalso \FV(\sigma)\subseteq \Gamma}
{\Gamma \vdash t~[\sigma] : \tau[\alpha\mapsto\sigma]}
}

\nc\FRules{
\Tautology
%
\infrule[$\R$I]
{\Gamma,x:\sigma \vdash t : \tau
  \andalso \FV(\sigma) \subseteq \Gamma}
{\Gamma \vdash (\Abs{x:\sigma}t) : \sigma\R\tau}
%
\infrule[$\R$E]
{\Gamma\vdash s:\sigma\R\tau
  \andalso \Gamma\vdash t:\sigma}
{\Gamma\vdash s~t:\tau}
%
\UniversalIntroduction
%
\UniversalElimination
}

\nc\ExistentialElimination{
\infrule[$\exists$E]
{\Gamma \vdash s : \All\alpha \sigma\R\tau
  \andalso \Gamma \vdash t : (\All\alpha \sigma\R\bot) \R \bot
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash \AppCC~s~t:\tau}
}

\nc\DoubleNegationElimination{
\infrule[$\neg\neg$E]
{\Gamma \vdash t : \Dn{\tau}}
{\Gamma \vdash \CallCC~t : \tau}
}

\FRules

\DoubleNegationElimination

\ExistentialElimination

\subsection{Useful term families of Continuation Calculus}

Since System F is a subset of Continuation Calculus, the
useful terms $\Brouwer$ and $\Dni$ of System F
(section~\ref{sec:f-terms}, page~\pageref{sec:f-terms}) are also
useful terms of Continuation Calculus. The terms here deal
with pushing quantifiers into the argument positions of
functions, and with pulling them out of there. They are
type-indexed term families, but members of one family differ
from each other in annotated types only.

Unlike Existential F, there is no primitive existential
quantifier in Continuation Calculus. Instead, we define it as a
syntactic sugar.
\[
\Ex\alpha \tau = (\All\alpha \tau \R \bot) \R \bot
\]

Traditional introduction and elimination forms are easy to
encode.
\begin{align*}
\Box_{\sigma,\tau} & :
  \tau[\alpha\mapsto\sigma] \R \Ex\alpha\tau
  \\
\Box_{\sigma,\tau} & =
  \Abs{x : \tau[\alpha\mapsto\sigma]}
  \Abs{f : (\All\alpha \tau \R \bot)}
  f~[\sigma]~x
\end{align*}
%
\begin{align*}
\Unbox_{\sigma} & :
  (\Ex\alpha\sigma) \R
  (\All\beta (\All\alpha \sigma \R \beta) \R \beta)
  \\
\Unbox_{\sigma} & =
  \Abs{x : (\Ex\alpha\sigma)}
  \Tabs\beta
  \Abs{f : (\All\alpha \sigma \R \beta)}
  \AppCC~f~x
\end{align*}

The following are theorems in classical predicate calculus.
Consult Metamath.\footnote{
~\url{http://de.metamath.org/mpegif/19.35.html}
}
\begin{align*}
\Allin_\sigma & : \All\beta
  (\All\alpha \sigma\R\beta) \R
  (\Ex\alpha \sigma) \R \tau
  \\
\Allin_\sigma & = ~?
\end{align*}

\begin{align*}
\Allex_\sigma & : \All\beta
  ((\All\alpha\sigma) \R \beta) \R
  (\Ex\alpha \sigma \R \beta)
  \\
\Allex_\sigma & = ~?
\end{align*}

\begin{align*}
\Exex_\sigma & : \All\beta
  ((\Ex\alpha \sigma) \R \beta) \R
  (\All\alpha \sigma \R \beta)
  \\
\Exex_\sigma & = ~?
\end{align*}

\begin{align*}
\Exin_\sigma & : \All\beta
  (\Ex\alpha \sigma \R \beta) \R
  (\All\alpha\sigma) \R \beta
  \\
\Exin_\sigma & = ~?
\end{align*}

\subsection{Embedding Existential F in Continuation Calculus}

\section{System F}

\subsection{Grammar of System F}

\[
\begin{array}{lclr}
\Ftype
&\Or& \bot & \mbox{bottom type} \\
\\
\Fterm
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of System F}
~

\FRules

\subsection{Useful terms of System F}
\label{sec:f-terms}

\begin{align*}
\Dni & : \All\alpha \alpha \R (\Dn\alpha) \\
\Dni & = \Tabs\alpha \Abs{x:\alpha}
           \Abs{c : (\alpha \R \bot)} c~x
\end{align*}

\begin{align*}
\Brouwer & : \All\alpha (\Dn{(\alpha\R\bot)}) \R (\alpha \R \bot) \\
\Brouwer & = \Tabs\alpha \Abs{f:(\Dn{(\alpha\R\bot)})}
           \Abs{x:\alpha} f~(\Dni~[\alpha]~x)
\end{align*}

\subsection{Embedding Continuation Calculus in System F}

Due to Curry-Howard correspondence, the embedding of
Continuation Calculus in System F can be viewed from either a
logical or a programming perspective.
\begin{itemize}
\item From the logical point of view, the embedding is an
instance of Kolmogorov's negative translation from classical
logic to intuitionistic logic.
\item From the programming point of view, the embedding is a
continuation-passing-style transformation that gets rid of
$\CallCC$ and $\AppCC$.
\end{itemize}
If $\tau$ is a type in Continuation Calculus, then $\tau^K$
shall be the corresponding type in System F. It is a similar
correspondence between contexts $\Gamma$ and $\Gamma^K$, or
between terms $t$ and $t^K$. The aforementioned embedding
transforms typing judgements in Continuation Calculus to typing
judgements in F. We shall call it ``$\Cps$''.

\begin{align*}
\alpha^K & =
  \Dn\alpha
  \\
(\sigma \R \tau)^K & =
  \Dn{(\sigma^K \R \tau^K)}
  \\
(\All\alpha\tau)^K & =
  \Dn{(\All\alpha\tau^K)}
  \\
\bot^K & =
  \Dn\bot
\end{align*}

\begin{align*}
(\Gamma, x:\tau)^K & =
  \Gamma^K, x:\tau^K
  \\
(\Gamma, \alpha)^K & =
  \Gamma^K, \alpha
  \\
\epsilon^K & =
  \epsilon
\end{align*}

% cps: tautology
\begin{align*}
\Cps(\Gamma \vdash x : \tau) & =
  \Gamma^K \vdash x : \tau^K
\end{align*}

% cps: implication introduction
\begin{align*}
\Cps(\Gamma \vdash (\Abs{x:\sigma}t) : \sigma \R \tau) & =
  \Gamma^K \vdash (\Abs{x:\sigma}t)^K : \Dn{(\sigma^K \R \tau^K)} &
  \mbox{where}
  \\
\Gamma^K,x:\sigma^K \vdash t^K : \tau^K & =
  \Cps(\Gamma,x:\sigma \vdash t : \tau)
  \\
(\Abs{x:\sigma}t)^K & =
  \Abs{c : ((\sigma^K \R \tau^K) \R \bot)}c~(\Abs{x : \sigma^K} t^K)
\end{align*}

% cps: implication elimination
\begin{align*}
\Cps(\Gamma \vdash s~t : \tau) & =
  \Gamma^K \vdash (s~t)^K : \tau^K
  & \mbox{where}
  \\
\Gamma^K \vdash s^K : \Dn{(\sigma^K \R \tau^K)} & =
  \Cps(\Gamma \vdash s : \sigma \R \tau)
  \\
\Gamma^K \vdash t^K : \sigma^K & =
  \Cps(\Gamma \vdash t : \sigma)
  \\
\rho \R \bot & = \tau^K
  \\
(s~t)^K & =
  \Abs{c : \rho} s^K~(\Abs{f : \sigma^K \R \rho \R \bot} \\
  &\Indent t^K~(\Abs{x : \sigma^K} f~x~c))
\end{align*}

% cps: universal introduction
\begin{align*}
\Cps(\Gamma \vdash (\Tabs\alpha t) : \All\alpha \tau) & =
  \Gamma^K \vdash (\Tabs\alpha t)^K : \Dn{(\All\alpha \tau^K)}
  & \mbox{where}
  \\
\Gamma^K,\alpha \vdash t^K : \tau^K & =
  \Cps(\Gamma,\alpha \vdash t : \tau)
  \\
(\Tabs\alpha t)^K & =
  \Abs{c : ((\All\alpha \tau^K) \R \bot)}c~(\Tabs\alpha \tau^K)
\end{align*}

% cps: universal elimination
\begin{align*}
\Cps(\Gamma \vdash t~[\sigma] : \tau[\alpha\mapsto\sigma]) & =
  \Gamma^K \vdash (t~[\sigma])^K :
  \Dn{\tau_1}
  & \mbox{where}
  \\
\Gamma^K \vdash t^K : \Dn{(\All\alpha \tau^K)} & =
  \Cps(\Gamma \vdash t : \All\alpha \tau)
  \\
\tau_1 & = \tau^K[(\Dn\alpha) \mapsto \sigma^K]
  \\
\tau_2 & = \tau^K[\alpha \mapsto \sigma^K]
  \\
\rho \R \bot & = \sigma^K
  \\
 (t~[\sigma])^K & =
  \Abs{c : (\tau_1 \R \bot)} t^K~(\Abs{x : (\All\alpha\tau)} \\
  &\Indent
  c~\Undo_{\alpha,\rho}(x~[\sigma^K], \tau))
\end{align*}

% cps: call/cc
\begin{align*}
\Cps(\Gamma \vdash \CallCC~t : \tau) & =
  \Gamma^K \vdash (\CallCC~t)^K : \tau^K
  &\mbox{where}
  \\
\Gamma^K \vdash t^K : \rho & =
  \Cps(\Gamma \vdash t : \Dn\tau)
  \\
\rho & =
  (((((\tau^K \R \bot^K) \R\bot)\R\bot)
    \R \bot^K) \R\bot)\R\bot
  \\
\phi \R \bot & = \tau^K
  \\
(\CallCC~t)^K & =
  \Abs{c : \phi}
  t^K~(\Abs{f : (\Dn{(\tau^K\R\bot^K)}) \R \bot^K}
  \\ &\Indent
  f~(
  \Abs{g : (\tau^K \R \bot^K) \R \bot}
  \\ &\Indent\hspace{1em}
  g~(\Abs{x:\tau^K} \Abs{\Id : (\bot \R \bot)} x~c)
  \\ &\Indent
  )~(\Abs{z:\bot} z)
\end{align*}

% cps: app/cc
\begin{align*}
\Cps(\Gamma \vdash \AppCC~s~t : \tau) & =
  \Gamma^K \vdash (\AppCC~s~t)^K : \tau^K
  \hspace{10em}\mbox{where}
  \\
\Gamma^K \vdash s^K : \Dn{\rho_s} & =
  \Cps(\Gamma \vdash s : \All\alpha \sigma \R \tau)
  \\
\Gamma^K \vdash t^K : \Dn{\rho_t} & =
  \Cps(\Gamma \vdash t : (\All\alpha \sigma \R \bot) \R \bot)
  \\
\rho_s & = \All\alpha \Dn{(\sigma^K \R \tau^K)}
  \\
\rho_t & = (\Dn{(\All\alpha \Dn{(\sigma^K\R\bot^K)})}) \R \bot^K
  \\
\phi \R \bot & = \tau^K
  \\
(\AppCC~s~t)^K & =
  \Abs{c:\phi} s^K~(\Abs{k : \rho_s} t^K~(\Abs{f:\rho_t}
  \\ &\Indent
  f~(\Abs{g : (\All\alpha ((\sigma^K \R \tau^K) \R\bot) \R\bot) \R\bot}
  \\ &\Indent\hspace{1em}
  g~(\Tabs\alpha \Abs{h : ((\sigma^K \R \bot^K) \R \bot)}
  \\ &\Indent\hspace{2em}
  h~(\Abs{x : \sigma^K}\Abs{\Id : (\bot\R\bot)}
  \\ &\Indent\hspace{3em}
  k~[\alpha]~(\Abs{m : (\sigma^K \R \tau^K)} m~x~c
  \\ &\Indent
  ))))~(\Abs{z : \bot}z)))
\end{align*}

\begin{lemma}
[$\Undo$ and $\Redo$]
\label{lem:undo-redo}
For every type variable $\alpha$ and every type $\sigma$, there
exists a pair of computable metafunctions $\Undo_{\alpha,\sigma}$
and $\Redo_{\alpha,\sigma}$ such that
\begin{itemize}
\item
whenever
$\Gamma \vdash t : \tau^K[\alpha \mapsto (\sigma\R\bot)]$
we have
\[
\Gamma \vdash \Undo_{\alpha,\sigma}(t,\tau) :
  \tau^K[(\Dn\alpha) \mapsto (\sigma\R\bot)],
\]
\item
whenever
$\Gamma \vdash t' : \tau^K[(\Dn\alpha) \mapsto (\sigma\R\bot)]$
we have
\[
\Gamma \vdash \Redo_{\alpha,\sigma}(t',\tau) :
  \tau^K[\alpha \mapsto (\sigma\R\bot)].
\]
\end{itemize}
\end{lemma}

\begin{proof}
The proof consists essentially of threading double negation
introduction and Brouwer's double negation elimination
judiciously through a term of arbitrarily complex type. We shall
omit the subscripts $\alpha$, $\sigma$ and write simply $\Undo$,
$\Redo$ from now on. For every type $\rho$, write
\begin{align*}
\rho_1 & = \rho^K[(\Dn\alpha)\mapsto(\sigma\R\bot)],\\
\rho_2 & = \rho^K[\alpha\mapsto(\sigma\R\bot)].
\end{align*}
We will define $\Undo$ and $\Redo$ by induction on $\tau$.
\begin{align*}
\Undo(t,\alpha) & = \Brouwer~[\sigma]~t\\
\Redo(t',\alpha) & = \Dni~[\sigma]~t'\\
\\
\Undo(t,\rho\R\phi) & =
  \Abs{c : ((\rho_1 \R \phi_1) \R \bot)}
  t~(\Abs{f : \rho_2 \R \phi_2}\\
  &\Indent c~(\Abs{x : \rho_1}
  \Undo((f~\Redo(x, \rho)), \phi) ))\\
\Redo(t',\rho\R\phi) & =
  \Abs{c : ((\rho_2 \R \phi_2) \R \bot)}
  t'~(\Abs{f : \rho_1 \R \phi_1}\\
  &\Indent c~(\Abs{x : \rho_2}
  \Redo((f~\Undo(x, \rho)), \phi) ))\\
\\
\Undo(t, \All\beta \rho) & =
  \Abs{c : ((\All\beta \rho_1) \R \bot)}
  t~(\Abs{x : (\All\beta \rho_2)} \\
  &\Indent c~(\Tabs\beta \Undo(x~[\beta], \rho)) )\\
\Redo(t', \All\beta \rho) & =
  \Abs{c : ((\All\beta \rho_2) \R \bot)}
  t'~(\Abs{x : (\All\beta \rho_1)} \\
  &\Indent c~(\Tabs\beta \Redo(x~[\beta], \rho)) )\\
\\
\Undo(t, \Ex\beta \rho) & =
  \Abs{c : (\All\beta \rho_1 \R \bot)}
  t~(\Tabs\beta \Abs{x : \rho_2}
  c~[\beta]~\Undo(x,\rho) )\\
\Redo(t', \Ex\beta \rho) & =
  \Abs{c : (\All\beta \rho_2 \R \bot)}
  t'~(\Tabs\beta \Abs{x : \rho_1}
  c~[\beta]~\Redo(x,\rho) )\\
\\
\Undo(t,\bot) & = t \\
\Redo(t',\bot) & = t' \qedhere
\end{align*}
\end{proof}

\begin{lemma}
[substitution lemma for Kolmogorov's negative translation]
\label{lem:subst-kolmogorov}
\[
(\tau[\alpha\mapsto\sigma])^K =
\tau^K[(\Dn\alpha) \mapsto \sigma^K].
\]
\end{lemma}

\begin{proof}
[Proof by induction on $\tau$]
\end{proof}

\section{Unification of quantified names}
\label{sec:unify}

\section{Future work}

Support algebraic data types. We can pull out quantifiers from
the argument of a covariant type constructor (lists, tuples,
sums) just so, and we can pull out quantifiers from the argument
of a contravariant type constructor changing universals to
existentials and vice versa. I don't know what to do about
invariant type constructors. Maybe we just leave the quantifiers
inside their arguments and never try to unify them.

Let user define new typing rules for Existential F in
Continuation Calculus.

\end{document}
