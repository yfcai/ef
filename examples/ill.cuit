. DEMONSTRATING ILL-TYPED TERMS

f : ∃ε. ε → ε
f = λx : β. x

. existential can't be instantiated by the nonunversal thing ℤ
.f 5

. irreconciled constraint: ℤ ⊑ a → b
.g : ∀γ. ℤ → γ → γ
.g = λn : ℤ. λx : γ. n x

. it's okay to push a quantifier in.
h1 : ∀α. (α → ℤ) → ℤ
h2 : ((∀α. α) → ℤ) → ℤ
h2 = h1

. it's okay to pull a quantifier back out.
h3 : ∀α. (α → ℤ) → ℤ
h3 = h2

h5 : (∀α. α) → ℤ
h6 : ∃α. α → ℤ
h6 = h5

h7 : (∃α. α) → ℤ
h8 : ∀α. α → ℤ
h8 = h7

. can swap quantifiers (is beyond classical logic)
i1 : ∀α. ∃β. α → β
i2 : ∃β. ∀α. α → β
i2 = i1

i3 : ∀α. ∃β. α → β
i3 = i2

. hiding ill-typed application inside layers of abstractions won't
. prevent its detection
. λz : ℤ. λm : ℤ. λn : ℤ. m n

. this term is found to reduce to ill-typed term
.
.   λx3 : T2. (λx1 : ∀T1. T1. x1) x3
.
. if we disregard types during reduction. I think it means that
. we have to instantiate types during reduction to have soundness.
.
(λx0 : ∀T0. (T0 → T0) → T0 → T0. x0 (λx1 : ∀T1. T1. x1))
  (λx2 : T2 → T2. λx3 : T2. x2 x3)

. rant

  old =

  (λx0 : ∀T0. (T0 → T0) → T0 → T0.
      x0 (λx1 : ∀T1. T1. x1))
    (ΛT2. λx2 : T2 → T2. λx3 : T2. x2 x3)

  in F =

  (λx : ∀α. (α → α) → α → α.
      x [∀β. β] (λy : ∀β. β. y))
    (Λγ. λz : γ → γ. λw : γ. z w)
