\documentclass{amsart}
\usepackage[foot]{amsaddr}
\usepackage{bcprules,url,verbatim,multicol,enumerate}

\let\phi=\varphi % default phi looks like empty set
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}

\input{macros.tex}

\def\CT0{$\text{CT}_0$}

\title[The MPS model of possibly negative algebraic data types]
{The MacQueen-Plotkin-Sethi model of
\\
possibly negative algebraic data types}

\begin{document}

\maketitle

\def\thingsExpressibleInMpsModel{%
subtyping, universal types, union and intersection types,
recursive types, dependent types, and higher kinds%
}

\vfill

\[
\def\miniwidth{0.4\textwidth}
\renewcommand\arraystretch{1.5}
\begin{tabular}{ll}
\hline Syntactic object \hspace{1cm}\null& Semantic object \\


\hline Term & Value \\


\indent\texttt{plus 3 5} & \indent the number $8$ \\

\indent$\Abs x x$ & \indent identity function on $V$\\

\indent$\Abs f (\Abs x f~(x~x))~(\Abs x f~(x~x))$
&\indent
\begin{minipage}[t]{\miniwidth}\raggedright
the function mapping each $f\in V\R V$ to its least
fixed point, and each $v\notin V\R V$ to~$\Wrong$
\end{minipage}
\vspace{1ex}
\\


\hline Type string & Type \\


\indent\texttt{Nat} & \indent$\B N_\bot = \{\bot,0,1,2,\ldots\}$ \\

\indent\texttt{Int} & \indent$\B Z_\bot = \{\bot, 0, 1, -1, 2, -2, \ldots\}$\\

\indent$\texttt{Nat}\R\texttt{Int}$ & \indent$\{f\in V\R V \Or f(\B N_\bot)\subseteq \B Z_\bot\}$ \\

\indent$\All\alpha\alpha\R\alpha$ & \indent$\bigcap_{T\in\Type}\{f\in V\R V \Or f(T) \subseteq T\}$ \\

\indent \texttt{Bot} & \indent $\{\bot\}$ \\

\indent \texttt{Top} & \indent $V-\{\Wrong\}$ \\


\hline Typing judgement & Statement \\


\indent\texttt{plus 3 5} : \texttt{Nat} & \indent$8\in\B N_\bot$ \\

\indent $x:\texttt{Nat}\VST x:\texttt{Nat}$ & \indent
\begin{minipage}[t]{\miniwidth}
If $\rho(x)\in\B N_\bot$, then $\rho(x)\in\B N_\bot$
\end{minipage}\\

\indent
\begin{minipage}[t]{\miniwidth}
$\alpha ; \beta\in[\texttt{Bot},\alpha]\VSub
% $\\\null\hspace{2em}$
\beta\le\beta\R\alpha$
\end{minipage}
&
\indent
\begin{minipage}[t]{\miniwidth}\raggedright
For all $T_\alpha\in\Type$,\\
for all $T_\beta\in\Type$ with
$\{\bot\}\subseteq T_\beta\subseteq T_\alpha$,
we have
$T_\beta\subseteq\{f\in V\R V \Or f(T_\beta)\subseteq\B T_\alpha\}$
(It is a false statement.)
\end{minipage}
\vspace{1ex}
\\


\hline Typing derivation rule & Theorem \\


\begin{minipage}[t]{\miniwidth}\raggedright
\[\frac{
s:\texttt{Nat}\R\texttt{Int}\qquad
t:\texttt{Nat}
}{s~t:\texttt{Int}}\]
\end{minipage}
&
\begin{minipage}[t]{\miniwidth}\raggedright
If the term $s$ denotes $f\in\{g\Or g(\B N_\bot)\subseteq \B
Z_\bot\}$ and\\
$t$ denotes $v\in \B N_\bot$, then the denotation $f(v)$ of
the application $s~t$ belongs to $\B Z_\bot$
\end{minipage}
\end{tabular}
\]

\vfill

\section{Pros and cons}

Bracha (Pluggable type systems) recommends making the type system
of a language optional and independent of the language's runtime
behavior. Doing so confers several benefits.
\begin{enumerate}
\item A useful program can be executed even if it has no type.
\item Type systems can evolve faster than the language itself.
\item Type inference can be made optional as well, so that the
expressiveness of the type system is not bounded by the power of
the inference algorithm.
\end{enumerate}
We demonstrate the technique of denotational pluggable types for
purely functional languages. It achieves all of the above and
more:
\begin{enumerate}\setcounter{enumi}3
\item Several type systems can be used together. If each
subsystem satisfies strong type soundness, then their composite
enjoys strong type soundness as well; the composite type system
would never erroneously accept programs with runtime type errors.
\item Types defined in different subsystems can interact with
each other. It is possible to call library functions defined
in a different type system.
\end{enumerate}
The technique is applicable to a wide variety of type systems. It
gives straightforward interpretations to \thingsExpressibleInMpsModel.

The simplicity comes at a cost: There is a slight restriction on
what a type can be. Say a program $f$ approximates the program
$g$ if $f$ terminates on fewer inputs than $g$ but otherwise
behaves just like $g$. Every type $\tau$ must satisfy the
following conditions:
\begin{itemize}
\item The program \texttt{1 + true} does not have type $\tau$.
\item If $g$ has type $\tau$ and $f$ approximates $g$, then $f$
has type $\tau$.
\item If every program $f$ approximating $g$ has type $\tau$,
then $g$ has type $\tau$.
\end{itemize}
In particular, types cannot separate terminating programs from
nonterminating ones.

The technique guarantees nothing about the type checker's
performance; it may even run forever. Writing a nonterminating
type checker is as easy as writing a nonterminating program in
Java.

\section{Background}

A runtime type error occurs when a value is used in an unintended
way; examples include adding an integer and a truth value,
dereferencing a non-pointer, and calling a non-function. A type
system is \emph{sound} if no well-typed program encounters
runtime type errors during execution. Soundness is one of the
most important design goals of type systems.

There are several methods to prove a type system sound. We will
discuss two: the syntactic approach, and the domain-theoretic
approach.

\Par{The syntactic approach}

It is the current standard framework for soundness proofs.
\begin{enumerate}
\item Capture the runtime behavior of the language in a
small-step semantics such that terms with runtime type errors are
\emph{stuck}: Neither are they values, nor can they reduce to
other terms.
\item Demonstrate \emph{progress}: A well-typed term is either a
value or reduces to something else.
\item Demonstrate \emph{preservation}: If a term has type $\tau$
then it continues to have type $\tau$ after one reduction.
\end{enumerate}
Together, progress and preservation imply that well-typed terms
never get stuck, and thus cannot experience runtime type errors.

In most circumstances, we can ``append'' to a syntactic soundness
proof to accommodate new runtime behaviors without modifying
existing arguments. But we cannot take two systems proven sound
by the syntactic approach, take the union of their typing rules,
and expect soundness to hold for the result. The two syntactic
soundness proofs gave us progress and preservation for terms
typed purely with rules in one system; they say nothing about
terms typed with a mixture of rules from both systems.

\Par{The domain-theoretic approach}

\begin{enumerate}
\item Capture the runtime behavior of the language in a domain
equation. Define types as certain sets of values in the semantic
domain. Designate a special value $\Wrong$ for runtime type
errors, and make sure it is not a member of any type.
\item Construct an interpretation from terms to values in the
semantic domain. Show that if a term $t$ has type $\tau$, then
$t$ interprets to a member of $\tau$.
\end{enumerate}
Since no type contains $\Wrong$, well-typed programs do not
denote $\Wrong$, and their evaluation may not encounter runtime
type errors.

A domain-theoretic soundness proof is not extensible with new
runtime behaviors. Adding mutation to a purely functional
language, for example, requires a completely new domain equation.
The old arguments have to be rewritten, because their
foundation---the old domain equation---has become obsolete.

However, if we extend the type system without modifying the
runtime behavior, then we can keep interpreting terms into the
old semantic domain. If the new typing rules are sound on their
own, then they already meet the expectation of the old soundness
proof, namely that they assign type $\tau$ only to terms
interpreting to a member of $\tau$. In this way, the old proof
carries over even to terms typed with a mixture of old and new
rules, and type soundness continues to hold.

If types are pluggable, then the language's runtime behavior has
to stay constant in all possible type systems. In this situation,
a domain-theoretic type soundness proof is more extensible than a
syntactic proof.


\section{Roadmap}

To achieve safely pluggable types, we exploit the extensibility
of domain-theoretic type soundness proofs when the runtime system
never changes. These are the steps:
\begin{enumerate}
\item Choose a semantic domain. For purely functional languages,
a domain for untyped lambda calculus suffices.
\item Choose a theory of types for the semantic domain. We employ
the ideal model by MacQueen, Plotkin and Sethi. It can easily
express \thingsExpressibleInMpsModel.
\item Develop type systems such that each typing rule corresponds
to a true statement in the theory of types. This property tends
to be a part of the usual domain-theoretic soundness proof; it
often incurs no effort beyond what is required to write the
soundness proof in the first place.
\end{enumerate}
Thus typing rules become lemmas, typing judgements become
statements, and terms with type annotations become proofs. Typing
terms with a mixture of type systems is no more than writing
proofs with a larger collection of lemmas.

The next section discusses domains and the MacQueen-Plotkin-Sethi
model of types on a high level. We will only disclose the
technical details absolutely essential for understanding
pluggable types.

The section after that describes pluggable simply typed lambda
calculus as a warm-up example.

The section after that describes CT1, a pluggable type system
that supports unboxed impredicative polymorphism.

The section after that describes how to make System~F pluggable.
Using System~F and CT1 together, we make the inference of type
arguments optional.

The section after that adds subtyping and whatever else comes to
my mind.


\section{MacQueen-Plotkin-Sethi model of types}

Outline
\begin{enumerate}
\item domain equation
\item interpretation of untyped lambda calc into the domain
\item reflexive transitive antisymmetric ordering $\Sub$
\item topology, continuous functions, compact elements
\item rank of elements; every compact element has a finite rank
\item types
\item proximity between types
\item contractive, nonexpansive
\item type constructors: finite union, arbitrary intersection, recursive
\end{enumerate}



\section{Warm-up example: simply typed lambda calculus}




\section{Constrained type system version 1}


\input{appendix.tex}
\end{document}
