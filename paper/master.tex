% latex
\documentclass{amsart}
\usepackage{bcprules,url}
\title
[Impredicative type inference]
{
Impredicative type inference
\break
or
\break
partial proof reconstruction \break
for second-order classical logic
}

\let\phi=\varphi % default phi looks like empty set
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}

\input{macros.tex}
\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

Existential F is a type theory with impredicative polymorphism
and decidable typing of Church-style terms. It is well-suited as
the type system of practical programming languages, for the
following reasons.
\begin{enumerate}
\item All Church-style terms typeable in System~F are well-typed
in Existential~F. Some terms untypeable in F are well-typed in
Existential~F as well. Strictly fewer useful programs are ruled
out. (It's possible to give an example here.)

\item Despite (1), Existential~F retains strong type soundness.
Well-typed programs never produce runtime type errors.

\item Despite (1) and (2), it is decidable whether a Church-style
term is well-typed in Existential~F or not.

\item Existential~F enjoys first-class polymorphism. One can
enforce, at the type level, invariants such as ``ST monad must
discard all references before returning'', or ``lambda
abstractions in HOAS may not use catamorphisms to examine their
arguments''. (Examples require an encoding of ADTs.)

\item The conveniences of Existential~F come at a lower cost,
both for programmers and for language implementers, than the cost
of existing systems with first-class polymorphism. The programmer
does not have to think beyond System~F types. The implementer has
only to learn a bottom-up unification algorithm for type
checking, and can reuse any existing implementation of untyped
lambda calculus for program execution.
\end{enumerate}

Existential~F draws on humanity's vast and purely theoretic
knowledge about predicate logic and ``formulae-as-types notion of
control'' (tentative noun), to produce a solution of the
practical language engineering problem of decidable type
inference for first-class polymorphism. A side-product of the
type soundness proof is Continuation Calculus, a formalization
and automatic proof verifier of second-order classical logic.


\section{Related systems}

\nc\MLF{ML$^\textrm{F}$}

Considerable effort has been put into type inference for programs
using first-class polymorphism, and produced the following
systems (among others, perhaps). Most are based on Hindley-Milner
type system and take advantage of adaptations of algorithm~W to
infer annotations on monotype arguments, but none can infer the
type of a polymorphic function argument. In other words, they can
reconstruct the type of a fully polymorphic term only when it is
given in Church style. In contrast, we chose to design
Existential~F from a clean slate, gaining considerable simplicity
in theory at the cost of more argument type annotations for the
present. We expect to leverage existing research in bidirectional
or local type inference to reduce notation overhead in the
future.
\begin{itemize}
\item \MLF\ is a type theory where quantified type variables can
be subjected to two classes of constraints, flexible or rigid. It
can type all Church-style terms typeable in System~F, provided
that quantifier constraints are introduced at suitable places.

\item HML is a simplification of \MLF, where programmers need
only provide flexible constraints. It can type all terms typeable
in \MLF, but inherits from \MLF\ the need to constrain
quantifiers.

\item HMF is System~F where type abstractions and certain
polymorphic type instantiations can be inferred. It cannot type
all Church-style terms typeable in System~F and is sensitive to
partial application. If $(s~t)$ is well-typed in HMF, it could
happen that $(\mathrm{let}~x=s~\mathrm{in}~x~t)$ is ill-typed.


\item FPH is another variant of System~F where type abstractions
and other classes of type instantiations can be inferred. It
cannot infer type instantiations involving ADTs. (We need an
encoding of ADT to demonstrate strict superiority.)

\item System~IF is System~F where type applications can be
omitted in a function call if they can be inferred from the
argument type. It targets compilers using System~F as an
intermediate language and is not meant for human consumption.

\item Haskell's rank-$n$-types support Church-style terms
typeable in System~F if no type variable need be instantiated to
a polymorphic type. It types strictly fewer terms than HMF.
\end{itemize}

TODO: lambda calculi corresponding to versions of classical
logic.


\section{Executive summary of type soundness proof}
\label{sec:exe}

Existential~F is very easy to implement. We can simply erase all
types from terms in Existential~F and feed the result to some
implementation of untyped lambda calculus. The following theorem
sheds some light on why it works.

\begin{theorem}
[faithfulness of translation]
\label{thm:faith}
Let ``$\Cps$'' be our translation from Existential~F to System~F.
Suppose $s$ and $t$ are well-typed in Existential~F such that $s$
reduces to $t$. Choose a variable ``$\Halt$'' free in neither $s$
nor $t$. There exists an untyped term $t'$ such that the erased
versions of both $(\Cps(s)~\Halt)$ and $(\Cps(t)~\Halt)$ reduce
to $t'$.
\end{theorem}

Consequently, we do not have to cps-transform Existential~F
programs to execute them---it suffices to perform
$\beta$-reductions as if they were untyped.

In theorem~\ref{thm:faith}, we have taken the liberty to
call the translation from Existential~F to System~F ``$\Cps$''.
In truth, the translation consists of desugaring into
Continuation Calculus (\S\ref{sec:desugar}) followed by
the continuation-passing-style transformation (\S\ref{sec:cps}).

\begin{theorem}
[soundness of translation]
\label{thm:sound}
Let ``$\Cps$'' be our translation from Existential~F to System~F.
Suppose $s$ reduces to $t$ in Existential~F. If
\begin{enumerate}
\item $\Gamma\vdash\Cps(s):\Dn\sigma$ and\/
\item $\Gamma\vdash\Cps(t):\Dn\tau$,
\end{enumerate}
then $\tau$ is a more general type than $\sigma$ in System~F.
\end{theorem}

Together with strong normalization and type soundness of
System~F, theorems \ref{thm:faith} and~\ref{thm:sound} imply
strong normalization and type soundness of Existential~F.

\begin{corollary}
\label{cor:sound}
If\/ $\Gamma\vdash t:\tau$ in Existential~F, then every reduction
sequence of $t$ terminates with a unique value $v$ in the domain
of $\tau$.
\end{corollary}

\section{Existential F}

\subsection{Grammar of Existential F}

\nc\Ftype{
\tau & ::= & \alpha & \mbox{type variable} \\
&\Or& \tau \rightarrow \tau & \mbox{function type} \\
&\Or& \All\alpha\tau & \mbox{universal type} \\
}

\nc\CFtype{
\Ftype
&\Or& \Ex\alpha\tau & \mbox{existential type} \\
}

\nc\CFterm{
t & ::= & x & \mbox{variable} \\
&\Or& \Abs{x:\tau}t  & \mbox{lambda abstraction} \\
&\Or& t~t & \mbox{function application} \\
}

\nc\SelectiveTypeAmnesia{
&\Or& t~\{\Ex\alpha\tau\} & \mbox{selective type amnesia} \\
}

\nc\TypingContexts{
\Gamma & ::= & \Gamma, x : \tau & \mbox{term variable binding}\\
&\Or& \Gamma, \alpha& \mbox{type variable binding} \\
&\Or& \epsilon & \mbox{empty context}\\ \\
}

\[
\begin{array}{lclr}
% types
\CFtype
\\
% terms
\CFterm
\SelectiveTypeAmnesia
\\
% contexts
\TypingContexts
\end{array}
\]

\subsection{Typing of Existential F}
~

\nc\Tautology{
\infrule[Taut]
{x : \tau \in \Gamma}
{\Gamma \vdash x : \tau}
}

\nc\UniversalIntroduction{
\infrule[$\forall$I]
{\Gamma,\alpha \vdash t:\tau
  \andalso \alpha \notin \Gamma}
{\Gamma \vdash (\Tabs\alpha t) : \All\alpha\tau}
}

\nc\ExistentialIntroduction{
\infrule[$\exists$I]
{\Gamma \vdash t : \tau[\alpha\mapsto\sigma]}
{\Gamma \vdash t~\{\Ex\alpha\tau\} : \Ex\alpha\tau}
}

\nc\UniversalNegation{
\infrule[$\neg\forall$]
{\Gamma \vdash t : (\All\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \Ex\alpha \sigma \R \tau}
}

\nc\ExistentialNegation{
\infrule[$\neg\exists$]
{\Gamma \vdash t : (\Ex\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \All\alpha \sigma \R \tau}
}

\nc\SuperIntroduction{
\infrule[$\R\forall$I]
{\Gamma, A, x:\sigma \vdash t : \tau
  \andalso A = \FV(\sigma) - \Gamma}
{\Gamma \vdash (\Abs{x:\sigma}t) : \All A{\sigma\R\tau}}
}

\nc\SuperElimination{
\infrule[$\R\forall\exists$E]
{\Gamma \vdash s : \All{A} \Ex{E} \sigma_s \R \tau
  \andalso \Gamma \vdash t : \sigma_t \\
  \Unify(\All E \Ex A \sigma_s, \sigma_t) \downarrow \Mgsr}
{\Gamma \vdash s~t : \Mgsr(\tau)}
}

\Tautology

\SuperIntroduction

\SuperElimination

Unification is discussed in \S\ref{sec:unify}. The type-level
metafunction $\Mgsr$ stands for ``most general substitution and
requantification''.

\ExistentialIntroduction

\section{Continuation Calculus}

\subsection{Grammar of Continuation Calculus}

\nc\Fterm{
\CFterm
&\Or& \Tabs\alpha t & \mbox{type abstraction} \\
&\Or& t~[\tau] & \mbox{type application} \\
}

\[
\begin{array}{lclr}
% types
\Ftype
&\Or& \bot & \mbox{result type of continuations} \\
\\
% terms
\Fterm
&\Or& \AbortCC~t & \mbox{abort with current continuation} \\
&\Or& \ApplyCC~t~t & \mbox{apply with current continuation} \\
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of Continuation Calculus}
~

\nc\UniversalElimination{
\infrule[$\forall$E]
{\Gamma \vdash t : \All\alpha\tau
   \andalso \FV(\sigma)\subseteq \Gamma}
{\Gamma \vdash t~[\sigma] : \tau[\alpha\mapsto\sigma]}
}

\nc\FRules{
\Tautology
%
\infrule[$\R$I]
{\Gamma,x:\sigma \vdash t : \tau
  \andalso \FV(\sigma) \subseteq \Gamma}
{\Gamma \vdash (\Abs{x:\sigma}t) : \sigma\R\tau}
%
\infrule[$\R$E]
{\Gamma\vdash s:\sigma\R\tau
  \andalso \Gamma\vdash t:\sigma}
{\Gamma\vdash s~t:\tau}
%
\UniversalIntroduction
%
\UniversalElimination
}

\nc\ExistentialElimination{
\infrule[$\exists$E]
{\Gamma \vdash s : \All\alpha \sigma\R\tau
  \andalso \Gamma \vdash t : (\All\alpha \sigma\R\bot) \R \bot
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash \ApplyCC~s~t:\tau}
}

\nc\DoubleNegationElimination{
\infrule[$\neg\neg$E]
{\Gamma \vdash t : \Dn{\tau}}
{\Gamma \vdash \AbortCC~t : \tau}
}

\FRules

\DoubleNegationElimination

\ExistentialElimination

\subsection{Useful term families of Continuation Calculus}

Since System F is a subset of Continuation Calculus, the useful
terms $\Brouwer$ and $\Dni$ of System F (\S\ref{sec:f-terms},
page~\pageref{sec:f-terms}) are also useful terms of Continuation
Calculus. The terms here deal with pushing quantifiers into the
argument positions of functions, and with pulling them out of
there. They are type-indexed term families, but members of one
family differ from each other in annotated types only.

Unlike Existential F, there is no primitive existential
quantifier in Continuation Calculus. Instead, we define it as a
syntactic sugar.
\[
\Ex\alpha \tau ::= (\All\alpha \tau \R \bot) \R \bot
\]

Traditional introduction and elimination forms are easy to
encode.
\begin{align*}
\Pack_{\sigma,\tau} & :
  \tau[\alpha\mapsto\sigma] \R \Ex\alpha\tau
  \\
\Pack_{\sigma,\tau} & =
  \Abs{x : \tau[\alpha\mapsto\sigma]}
  \Abs{f : (\All\alpha \tau \R \bot)}
  f~[\sigma]~x
\end{align*}
%
\begin{align*}
\Unpack_{\sigma} & :
  (\Ex\alpha\sigma) \R
  (\All\beta (\All\alpha \sigma \R \beta) \R \beta)
  \\
\Unpack_{\sigma} & =
  \Abs{x : (\Ex\alpha\sigma)}
  \Tabs\beta
  \Abs{f : (\All\alpha \sigma \R \beta)}
  \ApplyCC~f~x
\end{align*}

This is the law of excluded middle. We can read it as saying that
a function of type $((\alpha\R\bot) \R \beta)$ either invokes its
argument or not. If it invokes the argument, then it provides
something of type $\alpha$. If it does not, then it provides
something of type $\beta$.
\begin{align*}
\Exmid & : \All{\alpha\beta}
  (\alpha \R \beta) \R
  ((\alpha\R\bot)\R\beta) \R
  \beta
\\
\Exmid & = \Tabs{\alpha\beta}
\Abs{f:(\alpha \R \beta)}
\Abs{g:((\alpha\R\bot)\R\beta)}
\\&\Indent
\AbortCC~(\Abs{k:\beta\R\bot}
\\&\Indent\hspace{1em}
k~(g~(\Abs{x:\alpha}
k~(f~x))))
\end{align*}

We need two technical lemmas in the proof of $\Allex$. Recall
that
\[
\Ex\alpha\sigma\R\bot ::= (\All\alpha\Dn\sigma)\R\bot.
\]
\begin{align*}
\Tech_1 & : ((\All\alpha\sigma)\R\bot) \R (\Ex\alpha\sigma\R\bot)
\\
\Tech_1 & =
\Abs{x : ((\All\alpha\sigma) \R \bot)}
\Abs{y : (\All\alpha \Dn\sigma)}
\\&\Indent
x~(\Tabs\alpha \AbortCC~(y~[\alpha]))
\end{align*}

\begin{align*}
\Tech_2 & : \All\beta \All\alpha
  (\sigma\R\bot) \R (\Ex\alpha \sigma\R\beta)
\\
\Tech_2 & = \Tabs\beta \Tabs\alpha \Abs{k : \sigma\R\bot}
\\&\Indent
\Pack_{\alpha,\sigma\R\beta}~(\Abs{x:\sigma}
\AbortCC~(\Abs{k' : (\beta\R\bot)} k~x))
\end{align*}

The following are theorems in classical predicate calculus.
Consult Metamath.\footnote{
~\url{http://de.metamath.org/mpegif/19.35.html}
}
\begin{align*}
\Allin_\sigma & : \All\beta
  (\All\alpha \sigma\R\beta) \R
  (\Ex\alpha \sigma) \R \tau
  \\
\Allin_\sigma & = \Tabs\beta
\Abs{f : \All\alpha \R \beta}
\Abs{x : \Ex\alpha \sigma}
\Unpack_\sigma~x~[\beta]~f
\end{align*}

\begin{align*}
\Allex_\sigma & : \All\beta
  ((\All\alpha\sigma) \R \beta) \R
  (\Ex\alpha \sigma \R \beta)
  \\
\Allex_\sigma & = \Tabs\beta
\Abs{f:(\All\alpha\sigma)\R\beta}
\\&\Indent
\Exmid~[\All\alpha\sigma]~[\Ex\alpha\sigma\R\beta]
\\&\Indent\hspace{1em}
(\Abs{x:(\All\alpha\sigma)}
\\&\Indent\Indent
\Pack_{\bot,\sigma\R\beta}~(
  \Abs{y:\sigma[\alpha\R\bot]} f~x))
\\&\Indent\hspace{1em}
(\Abs{k:(\All\alpha\sigma)\R\bot}
\\&\Indent\Indent
\Unpack_{\sigma\R\bot}~(\Tech_1~k)~[
  \Ex\alpha\sigma\R\beta
]~(\Tech_2~[\beta]))
\end{align*}

\begin{align*}
\Exex_\sigma & : \All\beta
  ((\Ex\alpha \sigma) \R \beta) \R
  (\All\alpha \sigma \R \beta)
  \\
\Exex_\sigma & = \Tabs\beta
  \Abs{f:((\Ex\alpha\sigma) \R \beta)}
  \\ &\Indent
  \AbortCC~(\Abs{c : ((\All\alpha \sigma \R \beta) \R \bot)}
  \\ &\Indent\Indent\hspace{2em}
  c~(\Tabs\alpha \Abs{x : \sigma}
  f~(\Pack_{\alpha,\sigma}~x)))
\end{align*}

\begin{align*}
\Exin_\sigma & : \All\beta
  (\Ex\alpha \sigma \R \beta) \R
  (\All\alpha\sigma) \R \beta
  \\
\Exin_\sigma & = \Tabs\beta
  \Abs{f : (\Ex\alpha \sigma \R \beta)}
  \Abs{x : (\All\alpha \sigma)}
  \\ &\hspace{5.3em}
\Unpack_{\sigma\R\beta}~f~[\beta]~(
\Tabs\alpha
\Abs{g : (\sigma \R \beta)}
g~(x~[\alpha]))
\end{align*}

\subsection{Embedding Existential F in Continuation Calculus}
\label{sec:desugar}

\section{System F}

\subsection{Grammar of System F}

\[
\begin{array}{lclr}
\Ftype
&\Or& \bot & \mbox{bottom type} \\
\\
\Fterm
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of System F}
~

\FRules

\subsection{Useful terms of System F}
\label{sec:f-terms}

\begin{align*}
\Dni & : \All\alpha \alpha \R (\Dn\alpha) \\
\Dni & = \Tabs\alpha \Abs{x:\alpha}
           \Abs{c : (\alpha \R \bot)} c~x
\end{align*}

\begin{align*}
\Brouwer & : \All\alpha (\Dn{(\alpha\R\bot)}) \R (\alpha \R \bot) \\
\Brouwer & = \Tabs\alpha \Abs{f:(\Dn{(\alpha\R\bot)})}
           \Abs{x:\alpha} f~(\Dni~[\alpha]~x)
\end{align*}

\subsection{Embedding Continuation Calculus in System F}
\label{sec:cps}

Fischer's CPS transformation extended by Felleisen, typed and
described by Timothy G. Griffin in ``A formula-as-types notion of
control''.

\begin{align*}
\alpha^* & =
  \alpha
  \\
(\sigma \R \tau)^* & =
  \sigma^* \R \Dn{\tau^*}
  \\
(\All\alpha\tau)^* & =
  \All\alpha (\Dn{\tau^*})
  \\
\bot^* & =
  \bot
\end{align*}

\begin{align*}
(\Gamma, x:\tau)^* & =
  \Gamma^*, x:\tau^*
  \\
(\Gamma, \alpha)^* & =
  \Gamma^*, \alpha
  \\
\epsilon^* & =
  \epsilon
\end{align*}

% cps: general scheme
In general, if $\Gamma \vdash t : \tau$, then
$\Gamma^* \vdash \Cps(t) : \Dn{\tau^*}$.
We define $\Cps$ by induction on the term component of the
judgement. Type annotations in the result of cps-transformation
are taken from the last rule in the typing derivation of the
input of cps-transformation.

% cps: tautology
\begin{align*}
\Cps(x)
& =
\Abs{k: (\tau^* \R \bot)} k~x
\end{align*}

% cps: implication introduction
\begin{align*}
\Cps(\Abs{x:\sigma}t)
& =
\Abs{k:\sigma^* \R \Dn{\tau^*}}
\\&\Indent
k~(\Abs{x:\sigma^*}\Cps(t))
\end{align*}

% cps: implication elimination
\begin{align*}
\Cps(s~t)
& =
\Abs{k:\tau^*\R\bot}
\\&\Indent
\Cps(s)~(\Abs{f:\sigma^* \R \Dn{\tau^*}}
\\&\Indent\hspace{5em}
\Cps(t)~(\Abs{x:\sigma^*}
f~x~k
))
\end{align*}

% cps: universal introduction
\begin{align*}
\Cps(\Tabs\alpha t)
& =
\Abs{k:((\All\alpha \Dn{\tau^*}) \R \bot)}
\\&\Indent
k~(\Tabs\alpha \Cps(t))
\end{align*}

% cps: universal elimination
\begin{align*}
\Cps(t~[\sigma])
& =
\Abs{k : \tau^*[\alpha\mapsto\sigma^*] \R \bot}
\\&\Indent
\Cps(t)~[\sigma^*]~(\Abs{x : \tau^*[\alpha\mapsto\sigma]} k~x)
\end{align*}

% cps: abort/cc
\begin{align*}
\Cps(\AbortCC~t)
& =
\Abs{k : \tau^*\R\bot}
\\&\Indent
\Cps(t)~(\Abs{x : (\tau^*\R\Dn\bot)\R\Dn\bot}
\\&\Indent\hspace{5em}
x~(\Abs{y : \tau^*} \Abs{\Id : (\bot\R\bot)}
\\&\Indent\hspace{8em}
k~y)~(\Abs{z : \bot}z))
\end{align*}

% cps: apply/cc
\begin{align*}
\Cps(\ApplyCC~s~t)
& =
\Abs{k : \tau^* \R \bot}
\\&\hspace{2em}
\Cps(s)~(\Abs{f : \All\alpha
  ((\sigma^*\R(\tau^*\R\bot)\R\bot)\R\bot)\R\bot}
\\&\Indent
\Cps(t)~(\Abs{w :
  (\All\alpha((\sigma^*\R \Dn\bot)\R\bot)\R\bot) \R
  \\&\Indent\hspace{5.5em}
  (\bot\R\bot) \R \bot}
\\&\Indent\hspace{1em}
w~(\Tabs\alpha \Abs{y :
  (\sigma^* \R \Dn\bot) \R \bot}
\\&\Indent\hspace{2em}
x~(\Abs{y : \sigma^*} \Abs{\Id : \bot \R \bot}
\\&\Indent\hspace{3em}
f~[\alpha]~(\Abs{g : \sigma^* \R \Dn{\tau^*}}
\\&\Indent\hspace{4em}
g~y~k))
\\&\Indent\hspace{1em}
)~(\Abs{z:\bot}z)
\end{align*}

\section{Faithfulness of the translation from Existential~F to
System~F}
\label{sec:faith}

This section proves theorem~\ref{thm:faith}.


\section{Unification of quantified names}
\label{sec:unify}

\section{Orderless Prenex Calculus}

\nc\Monotypes{
&&&\mbox{monotypes} \\
M, N
&::=& \alpha & \mbox{type variable} \\
&\Or& M \rightarrow N & \mbox{function type} \\
}

\nc\Prenexes{
&&&\mbox{sequences of type variables} \\
A, E
&::=& \epsilon \Or \alpha, A \\
&&&\mbox{prenexes} \\
P, Q
&::=& M \\
&\Or& \All A \Ex E M \\
\\
&&&\mbox{instantiators} \\
J, K
&::=& p_i & \mbox{pointer to one's own quantifiers} \\
&\Or& \cdots & \mbox{monotypes \& prenexes} \\
\\
}

\[
\begin{array}{lclr}
% types
\Monotypes\\
\Prenexes
\\
&&&\mbox{terms}\\
s, t
& ::= & x & \mbox{variable} \\
&\Or& \Abs{x:P}t  & \mbox{lambda abstraction} \\
&\Or& s~t & \mbox{function application} \\
&\Or& \Tabs\alpha t & \mbox{prenex abstraction} \\
&\Or& t~[J] & \mbox{instantiation} \\
\end{array}
\]


\section{Future work}

Support algebraic data types.
%
For starters, try Boehm-Berarducci encoding.
%
We can pull out quantifiers from the argument of a covariant type
constructor (lists, tuples, sums) just so, and we can pull out
quantifiers from the argument of a contravariant type constructor
changing universals to existentials and vice versa. I don't know
what to do about invariant type constructors. Maybe we just leave
the quantifiers inside their arguments and never try to unify
them.

Let user define new typing rules for Existential F in
Continuation Calculus.

\end{document}
