\documentclass{amsart}
\usepackage{bcprules,url,enumerate}
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[subsection]{Definition}

\def\thesubsection{\arabic{subsection}}

\input{../paper/macros.tex}
\begin{document}

\begin{syntax}
\mbox{type}\\
\sigma, \tau
&::=& \iota_0 \Or \iota_1 \Or \cdots &\mbox{base type}\\
&|& \alpha \Or \beta \Or \cdots & \mbox{type variable} \\
&|& \tau \rightarrow \tau & \mbox{function type} \\
&|& \All\alpha\tau & \mbox{universal type} \\
&|& \Ex\alpha\tau & \mbox{existential type}
\\
\\
\mbox{term}\\
s, t & ::= & x & \mbox{variable} \\
& | & \Abs{x:\tau}t  & \mbox{lambda abstraction} \\
& | & t~t & \mbox{function application} \\
& | & \mbox{primitives}
\end{syntax}

\subsection{Domain}
The domain of values $V$ is the solution to the following domain
equations.
\begin{align*}
V &= F + B_0 + B_1 + \cdots + \{\Wrong\}
  &&\mbox{disjoint sum of domains}\\
F &= V \R V &&\mbox{continuous functions from $V$ to $V$}
\end{align*}
Here and elsewhere, we omit all domain-theoretic details, such as
the fact that domain equations are solved only up to isomorphism,
and that disjoint sum with a bottomless set (e.~g., $\{\Wrong\}$)
must be encoded as smash sum with a flat domain. To lighten
notational and conceptual burden, let us treat $B_i$, $F$ and
$\{\Wrong\}$ as if they were actual subsets of $V$.

\subsection{Wrongless downsets}
\label{wrongless}
Closed types denote wrongless downsets. A subset $S$ of the
domain $V$ is \emph{downward closed} if for all $u\in S$, all
elements smaller than $u$ in $V$ are contained in $S$. A subset
of $V$ is a \emph{wrongless downset} if it is downward closed and
does not contain $\Wrong$. Write $\Down$ for the family of all
wrongless downsets. $\Down$~is never empty; $\{\bot\}$ is a
wrongless downset, for example.

\subsection{Functionality of wrongless downsets}
\label{functionality}
The functionality of wrongless down\-sets is the trivial
generalization of Milner's adaptation of Scott's notion of
functionality~\cite{Milner78}.

Let $S_0$ and $S_1$ be wrongless downsets. The
\emph{functionality} from $S_0$ to $S_1$, writ $S_0\RR S_1$, is
the set of functions that always map values in $S_0$ to values in
$S_1$, but can map values outside $S_0$ to anything in $V$.
\[
S_0 \RR S_1 =
\{\bot\}\cup\{f\in F \Or f(S_0) \subseteq S_1\}.
\]
Function types denote functionalities. A functionality is defined
to be inclusive enough to contain all polymorphic functions
capable of ``instantiating'' to the desired function type.

\subsection{Closure properties of wrongless downsets}
The functionality between two wrongless downsets is a wrongless
downset. The intersection of any nonempty family of wrongless
downsets is a wrongless downset. The union of any nonempty family
of wrongless downsets is a wrongless downset.

\subsection{Denotation of types}
\label{denotation-types}
Closed types denote wrongless downsets. Open types denote a
function mapping each environment of wrongless downsets to a
wrongless downset.

Upper case $\Env$ refers to an environment mapping type variables
to wrongless downsets; lower case $\env$ will refer to an environment
mapping term variables to values in \S\ref{denotation-terms}.
\begin{align*}
\Sem{\iota_i}~\Env &= \{\bot\}\cup B_i\\
\Sem{\alpha}~\Env &= \Env(\alpha)\\
\Sem{\sigma\R\tau}~\Env&=
  (\Sem{\sigma}~\Env)\RR(\Sem{\tau}~\Env)\\
\Sem{\All\alpha\tau}~\Env&=
  {\textstyle\bigcap_{S\in\Down}}
  \left(\Sem\tau~(\Update\Env{\alpha\mapsto S})\right)\\
\Sem{\Ex\alpha\tau}~\Env&=
  {\textstyle\bigcup_{S\in\Down}}
  \left(\Sem\tau~(\Update\Env{\alpha\mapsto S})\right)
\end{align*}
The reader may verify that the right hand side of this definition
is always a wrongless downset. The family $\Down$ of all
wrongless downsets is defined in \S\ref{wrongless}. The
functionality construction $\RR$ is described in
\S\ref{functionality}.

\subsection{Equivalence of types}
Set-theoretic equality of the denotation of types induce an
equivalence on types. Examples:
\begin{enumerate}[(i)]
\item
$\Sem{\All\alpha\sigma\R\tau}=\Sem{\sigma\R(\All\alpha\tau)}$
where $\alpha\notin\FTV(\sigma)$,
\item
$\Sem{\Ex\alpha\sigma\R\tau}=\Sem{\sigma\R(\Ex\alpha\tau)}$
where $\alpha\notin\FTV(\sigma)$,
\item
$\Sem{\All\alpha\sigma\R\tau}=\Sem{(\Ex\alpha\sigma)\R\tau}$
where $\alpha\notin\FTV(\tau)$,
\item
$\Sem{\Ex\alpha\sigma\R\tau}=\Sem{(\All\alpha\sigma)\R\tau}$
where $\alpha\notin\FTV(\tau)$,
\item
$\Sem{\All\alpha\Ex\beta\tau}=\Sem{\Ex\beta\All\alpha\tau}$.
\end{enumerate}
Type equivalence expressed by (i) and (ii) holds for
intuitionistic logic. The type equivalence of (i) to (iv) holds
for classical logic. The equivalence of (v) is seen in neither.


\subsection{Denotation of terms}
\label{denotation-terms}
Terms denote values as if they were untyped. Primitives may
denote anything in $V$, as long as the value of each primitive
operator satisfies strong type soundness.

Upper case $\Env$ is type-level environment
(\S\ref{denotation-types}). Lower case $\env$ refers to an
environment mapping term variables to values in $V$.
\begin{align*}
\Sem{x}~\env&=\env(x)\\
\Sem{\Abs{x:\tau}t}~\env&=
  f\in F\text{ such that }
  f(v)=\Sem{t}~(\Update\env{x\mapsto v})
\\
\Sem{s~t}~\env&=
\begin{cases}
\Wrong&\text{if }(\Sem{s}~\env)\notin F\\
f(\Sem{t}~\env)&\text{if }(\Sem{s}~\env)=f\in F
\end{cases}
\\
\Sem{\mathrm{primitive}}~\env&=\cdots
\end{align*}


\subsection{Constraint-based subtyping}

We define a syntactic relation $\Sub$ on polytypes. We call it
the \emph{subtype} relation because $\sigma \Sub \tau$ implies
$V^\sigma \subseteq V^\tau$ (theorem~\ref{subsound}).

\subsection{Syntax of constraints}~

\begin{syntax}
\mbox{degrees of freedom}\\
\Delta
&::=& \emptyset \\
&|& \alpha,\Delta
\\
\\
\mbox{list of constraints}\\
C
&::=& \emptyset \\
&|& \rho_0 \Sub \rho_1, C
\end{syntax}

\subsection{Derivation of constraint judgements}~

\infrule[C-Refl]
{}
{\Delta \vdash \rho_0\Sub\rho_0,\rho_1\Sub\rho_1,
\ldots,\rho_n\Sub\rho_n}

TODO: separate quantifier lifting from {\sc C-Arrow} into another rule.

Need not argue that we implement all the rules here.
We can implement any weaker subtyping relation, any weaker typing
relation. Soundness holds through.

\infrule[C-Arrow]
{
\arraycolsep=1pt
\begin{array}[b]{rl}
\bar\alpha &= \bar\alpha_0,\bar\alpha_1,\bar\alpha_{01}\\
\bar\alpha_0 &\subseteq \FTV(\theta_0) - \FTV(\theta_1)\\
\bar\alpha_1 &\subseteq \FTV(\theta_1) - \FTV(\theta_0)\\
\bar\alpha_{01} &\subseteq \FTV(\theta_0) \cap \FTV(\theta_1)\\
\bar\beta &= \bar\beta_0,\bar\beta_1,\bar\beta_{01}\\
&\vdots\\
\bar\delta_{23} &\subseteq \FTV(\theta_2) \cap \FTV(\theta_3)
\end{array}
\andalso
\begin{array}[b]{rcl}
\Delta,\bar\alpha_{01},\bar\delta_{23} &~\vdash~&
(\All{\bar\delta_2}\Ex{\bar\gamma_2}\theta_2)
\Sub
(\All{\bar\beta_0}\Ex{\bar\alpha_0}\theta_0),
\\ &&
(\All{\bar\alpha_1}\Ex{\bar\beta_1}\theta_1)
\Sub
(\All{\bar\gamma_3}\Ex{\bar\delta_3}\theta_3),
\\ &&
C
\end{array}
}
{\Delta\vdash
(\All{\bar\alpha} \Ex{\bar\beta} \theta_0 \R \theta_1)
\Sub
(\All{\bar\gamma} \Ex{\bar\delta} \theta_2 \R \theta_3)
,C}


\infrule[C-Loner]
{\alpha\notin\Delta\cup\FTV(C)
\andalso
\Delta\vdash
\{ \rho_i\Sub\rho_j' \Or 0 \le i \le m, 0 \le j \le n \}
\cup C
}
{
\Delta,\alpha \vdash
\rho_0\Sub\alpha,\ldots,\rho_m\Sub\alpha,
\alpha\Sub\rho_0',\ldots,\alpha\Sub\rho_n',C
}

\begin{definition}
[subtype relation]
A polytype $\sigma$ is a subtype of another polytype $\tau$, writ
$\sigma \Sub \tau$, if there exists a derivation of
$\emptyset\vdash\sigma\Sub\tau$.
\end{definition}

\begin{theorem}
[soundness of subtyping]
\label{subsound}
$V^\sigma\subseteq V^\tau$ whenever $\sigma\Sub\tau$.
\end{theorem}

\begin{proof}[Proof idea]
Induction on derivation of constraint judgements, with the
following induction hypothesis:

A monotype instantiation of $\Delta$ is a substitution where each
type variable in $\Delta$ is mapped to a monotype. If there is a
derivation of $\Delta\vdash C$, then for each monotype
instantiation $f$ of $\Delta$ and each constraint
$\rho_0\Sub\rho_1$ in $C$, we have $V^{f(\rho_0)}\subseteq
V^{f(\rho_1)}$.
\end{proof}

\begin{definition}
[loner; unsure whether will be useful]
\label{loner}
A type variable $\alpha$ is a loner in the constraint list $C$ if
\begin{enumerate}
\item $C$ contains constraints of the form
$\alpha\Sub\rho$ or $\rho\Sub\alpha$ with
$\alpha\notin\FTV(\rho)$, and
\item $\alpha$ never occurs free in other constraints of $C$.
\end{enumerate}
If $\alpha$ is a loner in $C$, then
\begin{align*}
\LHS(\alpha)&=\{\rho \Or (\rho\Sub\alpha) \in C\}\\
\RHS(\alpha)&=\{\rho \Or (\alpha\Sub\rho) \in C\}\\
\end{align*}
\end{definition}



\input{bib.tex}\end{document}
