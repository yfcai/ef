\documentclass{amsart}
\usepackage[foot]{amsaddr}
\usepackage{bcprules,url,verbatim,multicol,enumerate}

\let\phi=\varphi % default phi looks like empty set
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}

\input{macros.tex}

\def\CT0{$\text{CT}_0$}

\title[The MPS model of possibly negative algebraic data types]
{The MacQueen-Plotkin-Sethi model of
\\
possibly negative algebraic data types}

\begin{document}

\maketitle

\def\thingsExpressibleInMpsModel{%
subtyping, universal types, union and intersection types,
recursive types, dependent types, and higher kinds%
}

\section{Pros and cons}

Bracha (Pluggable type systems) recommends making the type system
of a language optional and independent of the language's runtime
behavior. Doing so confers several benefits.
\begin{enumerate}
\item A useful program can be executed even if it has no type.
\item Type systems can evolve faster than the language itself.
\item Type inference can be made optional as well, so that the
expressiveness of the type system is not bounded by the power of
the inference algorithm.
\end{enumerate}
We demonstrate the technique of denotational pluggable types for
purely functional languages. It achieves all of the above and
more:
\begin{enumerate}\setcounter{enumi}3
\item Several type systems can be used together. If each
subsystem satisfies strong type soundness, then their composite
enjoys strong type soundness as well; the composite type system
would never erroneously accept programs with runtime type errors.
\item Types defined in different subsystems can interact with
each other. It is possible to call library functions defined
in a different type system.
\end{enumerate}
The technique is applicable to a wide variety of type systems. It
gives straightforward interpretations to \thingsExpressibleInMpsModel.

The simplicity comes at a cost: There is a slight restriction on
what a type can be. Say a program $f$ approximates the program
$g$ if $f$ terminates on fewer inputs than $g$ but otherwise
behaves just like $g$. Every type $\tau$ must satisfy the
following conditions:
\begin{itemize}
\item The program \texttt{1 + true} does not have type $\tau$.
\item If $g$ has type $\tau$ and $f$ approximates $g$, then $f$
has type $\tau$.
\item If every program $f$ approximating $g$ has type $\tau$,
then $g$ has type $\tau$.
\end{itemize}
In particular, types cannot separate terminating programs from
nonterminating ones.

The technique guarantees nothing about the type checker's
performance; it may even run forever. Writing a nonterminating
type checker is as easy as writing a nonterminating program in
Java.

\section{Background}

A runtime type error occurs when a value is used in an unintended
way; examples include adding an integer and a truth value,
dereferencing a non-pointer, and calling a non-function. A type
system is \emph{sound} if no well-typed program encounters
runtime type errors during execution. Soundness is one of the
most important design goals of type systems.

There are several methods to prove a type system sound. We will
discuss two: the syntactic approach, and the domain-theoretic
approach.

\Par{The syntactic approach}

It is the current standard framework for soundness proofs.
\begin{enumerate}
\item Capture the runtime behavior of the language in a
small-step semantics such that terms with runtime type errors are
\emph{stuck}: Neither are they values, nor can they reduce to
other terms.
\item Demonstrate \emph{progress}: A well-typed term is either a
value or reduces to something else.
\item Demonstrate \emph{preservation}: If a term has type $\tau$
then it continues to have type $\tau$ after one reduction.
\end{enumerate}
Together, progress and preservation imply that well-typed terms
never get stuck, and thus cannot experience runtime type errors.

In most circumstances, we can ``append'' to a syntactic soundness
proof to accommodate new runtime behaviors without modifying
existing arguments. But we cannot take two systems proven sound
by the syntactic approach, take the union of their typing rules,
and expect soundness to hold for the result. The two syntactic
soundness proofs gave us progress and preservation for terms
typed purely with rules in one system; they say nothing about
terms typed with a mixture of rules from both systems.

\Par{The domain-theoretic approach}

\begin{enumerate}
\item Capture the runtime behavior of the language in a domain
equation. Define types as certain sets of values in the semantic
domain. Designate a special value $\Wrong$ for runtime type
errors, and make sure it is not a member of any type.
\item Construct an interpretation from terms to values in the
semantic domain. Show that if a term $t$ has type $\tau$, then
$t$ interprets to a member of $\tau$.
\end{enumerate}
Since no type contains $\Wrong$, well-typed programs do not
denote $\Wrong$, and their evaluation may not encounter runtime
type errors.

A domain-theoretic soundness proof is not extensible with new
runtime behaviors. Adding mutation to a purely functional
language, for example, requires a completely new domain equation.
The old arguments have to be rewritten, because their
foundation---the old domain equation---has become obsolete.

However, if we extend the type system without modifying the
runtime behavior, then we can keep interpreting terms into the
old semantic domain. If the new typing rules are sound on their
own, then they already meet the expectation of the old soundness
proof, namely that they assign type $\tau$ only to terms
interpreting to a member of $\tau$. In this way, the old proof
carries over even to terms typed with a mixture of old and new
rules, and type soundness continues to hold.

If types are pluggable, then the language's runtime behavior has
to stay constant in all possible type systems. In this situation,
a domain-theoretic type soundness proof is more extensible than a
syntactic proof.


\section{Roadmap}

To achieve safely pluggable types, we exploit the extensibility
of domain-theoretic type soundness proofs when the runtime system
never changes. These are the steps:
\begin{enumerate}
\item Choose a semantic domain. For purely functional languages,
a domain for untyped lambda calculus suffices.
\item Choose a theory of types for the semantic domain. We employ
the ideal model by MacQueen, Plotkin and Sethi. It can easily
express \thingsExpressibleInMpsModel.
\item Develop type systems such that each typing rule corresponds
to a true statement in the theory of types. This property tends
to be a part of the usual domain-theoretic soundness proof; it
often incurs no effort beyond what is required to write the
soundness proof in the first place.
\end{enumerate}
Thus typing rules become lemmas, typing judgements become
statements, and terms with type annotations become proofs. Typing
terms with a mixture of type systems is no more than writing
proofs with a larger collection of lemmas.

The next section discusses domains and the MacQueen-Plotkin-Sethi
model of types on a high level. We will only disclose the
technical details absolutely essential for understanding
pluggable types.

The section after that describes CT1, a pluggable type system
that supports unboxed impredicative polymorphism.

The section after that describes how to make System~F pluggable.
Using System~F and CT1 together, we make the inference of type
arguments optional.

The section after that adds subtyping and whatever else comes to
my mind.

\section{What is a type?}

MacQueen, Plotkin and Sethi proposed a notion of types as sets in
a semantic domain of untyped lambda calculus. These types are
rough descriptions of the behavior of their inhabitants. For
example, if a function $f$ has type $\mathbb Z\R\mathbb Z$, then
$f$ is guaranteed to map an integer to another integer. If $g$
has type $\All\alpha \alpha\R\alpha$, then $g(x)$ inhabits every
type where $x$ is an inhabitant. Under this scheme, a recursive
type equation such as
\[
\mathit{List} = \{\mathit{nil}\} + (\mathbb Z \times \mathit{List})
\]
has a unique solution, and thereby defines a type.

In the MacQueen-Plotkin-Sethi model, a type is a nonempty
Scott-closed subset of the value domain $V$. The existence and
uniqueness proof for solutions of recursive type equations
depends crucially on the properties of Scott-closed sets.


\Par{Value domain}

$V$ is a set containing all functions definable in untyped lambda
calculus. It is the solution of the following equation up to
set-theoretic isomorphism:
\begin{equation}\label{domain-eq}
V \cong B + (V + V) + (V \times V) + (V \R V) + \{\bot, \top\}.
\end{equation}
Here, $B$ is any set of base values. In a practical programming
language, its members are often truth values, integers and
floating point numbers. The symbol $+$ denotes disjoint union,
and $\times$ denotes cartesian product. They give rise to a
\emph{approximation} partial order $\Sub$ under which $\bot$ is
always the least element, $\top$ is always the greatest element,
and members of $B$ are incomparable with one another. The
approximation partial order $\Sub$ determines a Scott topology on
$V$, and the function space $(V \R V)$ consists of the continuous
functions of the Scott topology. We will talk about Scott
topologies later. For now, it suffices to appreciate that $V$
contains base values, function values and values of (not
necessarily positive) algebraic data types.

There are a number of ways to construct a set $V$ satisfying
equation~\eqref{domain-eq}. We use the construction producing a
\emph{consistently complete algebraic cpo}. We will use the
property of $V$ as a cpo in the definition of types, and use the
algebraicity of $V$ to establish that recursive algebraic data
types are well-defined. Consistent completeness is unused in our
development.

Previous works define an extra member $\Wrong$ of $V$ to stand
for runtime type errors. We use the maximum element $\top$ for
runtime type errors instead, so that $\Wrong$ does not have to be
purposefully excluded from every type. In fact, our types are
closed nonempty proper subsets of $V$ under its Scott topology.

\Par{Complete partial orders}

Let $\sqsubseteq$ be a partial order over $V$. A subset of $V$ is
\emph{directed} if every two members $x$, $y$ of $A$ has an upper
bound $z$ in $A$ such that $z\sqsupseteq x$ and $z\sqsupseteq y$.
The partially ordered set $V$ is a \emph{complete partial order},
or \emph{cpo}, if every directed subset of $V$ has a supremum
(i.~e., least upper bound) in $V$.

Our chosen solution of equation~\eqref{domain-eq} is a cpo. We
will henceforth use that fact without further qualification.

\Par{Scott topology}

The solution to domain equation~\eqref{domain-eq} should impose a
\emph{approximation} partial order $\Sub$ on $V$ satisfying the
following properties.
\begin{itemize}
\item $\bot$ is the least element: $\bot\Sub v$ for all $v\in V$.
\item $\top$ is the greatest element: $v\Sub\top$ for all $v\in
V$.
\item Base values are incomparable: If $u,v\in B$, then
$u\not\Sub v$ and $v\not\Sub u$.
\end{itemize}
A topology of $V$ is any labeling of subsets of $V$ as
\emph{open} such that
\begin{itemize}
\item $\emptyset$ and $V$ are open,
\item the union of any family of open sets is open,
\item the intersection of a finite number of open sets is open.
\end{itemize}
We mentioned that the function space $(V\R V)$ consists of the
continuous functions according to the Scott topology. A function
is continuous if its preimage of each open set is an open set.

\begin{samepage}
The Scott topology of $V$ labels a subset $S$ open if it
satisfies the following conditions.
\begin{itemize}
\item $S$ is \emph{upward-closed}: If $u\in S$ and $u\Sub v$,
then $v\in S$.
\item $S$ is \emph{inaccessible by directed supremums}: If $A$ is
a directed set disjoint from $S$, then the supremum of $A$ is
outside $S$.
\end{itemize}
\end{samepage}

A set is \emph{closed} if it is the complement of an open set.

\begin{lemma}[Characterizing closed sets of Scott topology]
A set $S\subseteq V$ is closed under Scott topology if and
only if it satisfies the following conditions.
\begin{itemize}
\item $S$ is \emph{downward-closed}: If $v\Sub u$ and $u\in S$,
then $v\in S$.
\item $S$ is \emph{closed under directed supremums}: If
$A$ is a directed subset of $S$, then the supremum of $A$ is a
member of $S$.
\end{itemize}
\end{lemma}

\begin{proof}
$S$ is downward-closed if and only if its complement is
upward-closed. $S$ is closed under directed supremums if and only
if its complement is inaccessible by directed supremums.
\end{proof}

\Par{Types}

A subset of $V$ is a \emph{type} if it is a proper closed set
under the Scott topology. In other words, types are nonempty
proper subsets of $V$ closed downward and under directed
supremums. If $v\in T$, then we say that the value $v$
\emph{inhabits} the type $T$, and that $v$ is an
\emph{inhabitant} of $T$.

We will use the property of types as closed sets to establish
well-approximation of recursive algebraic data types.

\begin{lemma}
$\bot$ inhabits every type. $\top$ does not inhabit any type.
\end{lemma}

\section{Recursively defined types}

\Par{Road map}

Let us reproduce the result by MacQueen, Plotkin and Sethi that
types can be defined by recursive equations. For example, the
type of heterogeneous lists is defined by the equation
\[
\texttt{List} = \texttt{Unit} + (V \times \texttt{List}),
\]
which holds with set-theoretic identity. The argument has 3
steps.
\begin{enumerate}[(i)]
\item Define the distance between every pair of types, and
establish completeness of the resulting metric space in the sense
that every Cauchy sequence of types converges to a type.
\item Show that the product, sum and function type constructions
are contractive in both arguments,
\item Invoke the Banach fixed-point theorem on the nonempty
complete metric space of types to show that every contraction
mapping between types has a unique fixed point. By (2), a
recursive type equation defines a unique type if its right hand
side uses only the product, sum and function type constructions.
\end{enumerate}

Step~(i) works for every distance function in a certain family.
But step~(ii) works for only one particular distance function,
whose definition depends crucially on the properties of $V$ as an
algebraic cpo.

\Par{Compact elements and algebraic cpos}

An element $v\in V$ is \emph{compact} if for all directed set $A$
such that $v\Sub\sup A$, there exists $u\in A$ such that $v\Sub
u$.

For any subset $S\subseteq V$, write $S_c$ for the set of compact
elements in $S$. A cpo $V$ is \emph{algebraic} if every $v\in V$
is the supremum of smaller compact elements:
\[
v=\sup \{u \in V_c \Or u \Sub v \}.
\]
Our chosen solution of equation~\eqref{domain-eq} is an algebraic
cpo. We will use its algebraicity without ceremony from now on.

\begin{lemma}
Let $V$ be an algebraic cpo. A subset $S$ contains every compact
element, or $S\supseteq V_c$, if and only if for every $v\in V$,
\[
v=\sup\{u\in S \Or u\Sub v\}.
\]
\end{lemma}

\begin{proof}
($\Rightarrow$) By algebraicity and because $V_c\subseteq S$,
\[
v=\sup\{u\in V_c \Or u \Sub v\} \Sub \sup\{u\in S \Or u \Sub v\}.
\]
Since $v$ is an upper bound of $\{u\in S \Or u \Sub v\}$, we also
have
\[
v\Sup \sup\{u\in S \Or u \Sub v\}.
\]
The proof goal follows from antisymmetry of the approximation
partial order $\Sub$.

($\Leftarrow$) Choose arbitrary $v\in V_c$. We are to show $v\in
S$. Let $A= \{u \in S \Or u \Sub v\}$. By assumption $v=\sup A$.
Since $v$ is compact, there exists $u'\in A$ such that $v\Sub
u'$. But we also have $u'\Sub v$ by definition of $A$, which
implies $v=u'\in A\subseteq S$.
\end{proof}

\Par{Rank}

\begin{lemma}
Every compact element has a rank.
\end{lemma}

\Par{Converging sequences of sets}
Let us recall the standard definition of convergence.

The \emph{limit superior} of an infinite sequence of sets
$S_1,S_2,\ldots$ is
\[
\limsup_{n\rightarrow\infty}S_n =
\bigcap_{n=1}^\infty\bigcup_{i = n}^\infty S_i.
\]
The \emph{limit inferior} is
\[
\liminf_{n\rightarrow\infty}S_n =
\bigcup_{n=1}^\infty\bigcap_{i = n}^\infty S_i.
\]
If the limit superior and limit inferior are equal, then the
sequence $S_1,S_2,\ldots$ \emph{converges}, and its \emph{limit}
is
\[
S = \limsup_{n\rightarrow\infty}S_n = \liminf_{n\rightarrow\infty}S_n.
\]

\Par{Metric space of types}

Let ``$\Rank$'' be an arbitrary function from $V$ to $\mathbb R$.
The proximity of two types $S$, $T$ is the smallest rank of a
value in the symmetric difference of $S$ and $T$. If $S=T$, then
their proximity is $\infty$. The distance $d(S, T)$ between two
types is inverse exponential in their proximity:
\[
d(S,T) =
\left(\frac12\right)^{\mathrm{proximity}(S, T)}
%\frac1{2 ^{\mathrm{proximity}(S, T)}} % looks worse
 \]
It is easy to verify that the distance function $d$ satisfies the
requirements for forming a metric space over the set of types:
It is nonnegative, evaluates to $0$ only on equal types, is
commutative, and satisfies a stronger inequality than the
triangle inequality:
\[
d(R,T)\le\max(d(R,S),d(S,T)).
\]
To see it, let $v$ be the value of minimum rank $r$ in the
symmetric difference between $R$~and $T$, and suppose $v\in R-T$.
Then $d(R, T)=2^{-r}$. If $v\in S$, then $v\in S-T$ and
$d(S,T)\ge2^{-r}$. If $v\notin S$, then $d(R, S)\ge2^{-r}$.

\Par{Cauchy sequences}

An infinite sequence $T_1,T_2,\ldots$ of types is Cauchy if for
every $\epsilon > 0$ there exists $n\in\mathbb N$ such that for
all $i,j\ge n$, the distance between $T_i$~and $T_j$ is smaller
than $\epsilon$.

\begin{theorem}
No matter which rank function is chosen, the metric space of
types is complete in the sense that every Cauchy sequence of
types converges to a type.
\end{theorem}

\begin{proof}
There are two proof goals.
\begin{enumerate}
\item Every Cauchy sequence of types converges.
\item The limit of a Cauchy sequence of types is a type.
\end{enumerate}

Part (1). Let $T_1,T_2,\ldots$ be a Cauchy sequence of types.
Knowing the standard result $\liminf T_n\subseteq\limsup T_n$,
we need only show $\limsup T_n\subseteq\liminf T_n$.

\def\Cauchy{\texttt{cauchy}}
\def\Hasv{{\texttt{has\textunderscore}v}}

Choose an arbitrary value
\[
v\in \limsup T_n = \bigcap_{n=1}^\infty\bigcup_{i = n}^\infty T_i.
\]
Let $\epsilon=2^{-\Rank(v)}>0$. There exists a natural number
$\Cauchy$ such that for all $i,j\ge\Cauchy$, we have
$d(T_i,T_j)<\epsilon$. Since $v$ is a member of the limit
superior, there exists a natural number $\Hasv\ge\Cauchy$ such
that $v\in T_\Hasv$. If we pick any $i\ge\Hasv$, then we have
$v\in T_i$, because otherwise the contradiction
\[
d(T_\Hasv, T_i)\ge2^{-\Rank(v)}=\epsilon
\]
would arise. Thus
\[
v\in
\bigcap_{i=\Hasv}^\infty T_i\subseteq
\bigcup_{n=1}^\infty\bigcap_{i = n}^\infty T_i.
=\liminf T_n.
\]

Part (2). We will verify that the limit
\[
T=\limsup T_n=\liminf T_n
\]
is a nonempty proper subset of $V$ closed downward and closed
under directed supremum.
\end{proof}

\end{document}
