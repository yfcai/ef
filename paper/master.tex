\documentclass{amsart}
\usepackage[foot]{amsaddr}
\usepackage{bcprules,url,verbatim,multicol,enumerate}
\usepackage[utf8x]{inputenc}
\usepackage[greek,english]{babel}

\let\phi=\varphi % default phi looks like empty set
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}

\input{macros.tex}

\def\CT0{$\text{CT}_0$}

\title{Ideal model for pluggable types}


\def\thingsExpressibleInMpsModel{%
subtyping, universal types, union and intersection types,
recursive types, dependent types, and higher kinds%
}


\begin{document}

\begin{samepage}

\maketitle

\newskip\shrunken
\shrunken=-0.5cm plus 20cm minus 20cm

\begin{table}[h]
\caption{Correspondence between syntactic and semantic objects}
\label{corres}
\end{table}
\vskip\shrunken
% ...
\def\miniwidth{0.4\textwidth}
\renewcommand\arraystretch{1.5}
\begin{tabular}{ll}
\hline Syntactic object \hspace{1cm}\null& Semantic object \\


\hline Term & Value \\


\indent\texttt{plus 3 5} & \indent the number $8$ \\

\indent$\Abs x x$ & \indent identity function on $V$\\

\indent$\Abs f (\Abs x f~(x~x))~(\Abs x f~(x~x))$
&\indent
\begin{minipage}[t]{\miniwidth}\raggedright
the function mapping each $f\in V\R V$ to its least
fixed point, and each $v\notin V\R V$ to~$\Wrong$
\end{minipage}
\vspace{1ex}
\\


\hline Type expression & Mathematical object, possibly a type\\


\indent\texttt{Nat} & \indent$\B N_\bot = \{\bot,0,1,2,\ldots\}$ \\

\indent\texttt{Int} & \indent$\B Z_\bot = \{\bot, 0, 1, -1, 2, -2, \ldots\}$\\

\indent$\texttt{Nat}\R\texttt{Int}$ & \indent$\{f\in (V\R V)_\bot \Or f(\B N_\bot)\subseteq \B Z_\bot\}$ \\

\indent$\All\alpha\alpha\R\alpha$ & \indent$\bigcap_{T\in\Type}\{f\in (V\R V)_\bot \Or f(T) \subseteq T\}$ \\

\indent$\alpha\R\beta$ & \indent
\begin{minipage}[t]{\miniwidth}
A certain partial function mapping type environments to types
\end{minipage}
\vspace{1ex}
\\


\hline Judgement & Statement \\


\indent\texttt{plus 3 5} : \texttt{Nat} & \indent$8\in\B N_\bot$ \\

\indent $x:\texttt{Nat}\VST x:\texttt{Nat}$ & \indent
\begin{minipage}[t]{\miniwidth}
If $\rho(x)\in\B N_\bot$, then $\rho(x)\in\B N_\bot$
\end{minipage}\\

\indent
\begin{minipage}[t]{\miniwidth}
$\alpha ; \beta\in[\texttt{Bot},\alpha]\VSub
% $\\\null\hspace{2em}$
\beta\le\beta\R\alpha$
\end{minipage}
&
\indent
\begin{minipage}[t]{\miniwidth}\raggedright
For all $T_\alpha\in\Type$,\\
for all $T_\beta\in\Type$ with
$\{\bot\}\subseteq T_\beta\subseteq T_\alpha$,
we have
${T_\beta\subseteq\{f\in (V\R V)_\bot \Or f(T_\beta)\subseteq T_\alpha\}}$
(It is a false statement.)
\end{minipage}
\vspace{1ex}
\\


\hline Typing rule & Inference rule \\


\begin{minipage}[t]{\miniwidth}\raggedright
\[\frac{
s:\texttt{Nat}\R\texttt{Int}\qquad
t:\texttt{Nat}
}{s~t:\texttt{Int}}\]
\end{minipage}
&
\indent
\begin{minipage}[t]{\miniwidth}\raggedright
If the term $s$ denotes $f\in\{g\Or g(\B N_\bot)\subseteq \B
Z_\bot\}$ and\\
$t$ denotes $v\in \B N_\bot$, then draw the conclusion that
$s~t$ denotes $f(v)\in Z_\bot$.
\end{minipage}
\vspace{1ex}\\\hline
\end{tabular}

\end{samepage}

\section{Pros and cons}

Bracha (Pluggable type systems) recommends making the type system
of a language optional and independent of the language's runtime
behavior. Doing so confers several benefits.
\begin{enumerate}
\item A useful program can be executed even if it has no type.
\item Type systems can evolve faster than the language itself.
\item Type inference can be made optional as well, so that the
expressiveness of the type system is not bounded by the power of
the inference algorithm.
\end{enumerate}
We demonstrate the technique of denotational pluggable types for
purely functional languages. It achieves all of the above and
more:
\begin{enumerate}\setcounter{enumi}3
\item It is safe for type systems to work together. The composite
of several sound subsystems will continue to reject programs with
runtime type errors.
\item Types defined in different subsystems can interact with
each other. It is possible to call library functions defined
in a different type system.
\end{enumerate}
The technique is applicable to a wide variety of type systems. It
is straightforward to express \thingsExpressibleInMpsModel.

There are some restrictions on what a type can be. For example,
if a program~$f$ has type $T$, then every program $g$ has type
$T$ whenever $g$ is less terminating than $f$ but behaves
otherwise just like $f$. Types cannot separate terminating
programs from nonterminating ones.

The technique guarantees nothing about the type checker's
performance; it may run forever. Writing a nonterminating type
checker is as easy as writing a nonterminating program in Java.

\section{Background}

A runtime type error occurs when a value is used in an unintended
way; examples include adding an integer and a truth value,
dereferencing a non-pointer, and calling a non-function. A type
system is \emph{sound} if no well-typed program encounters
runtime type errors during execution. Soundness is one of the
most important design goals of type systems.

There are several methods to prove a type system sound. We will
discuss two: the syntactic approach, and the domain-theoretic
approach.

\Par{The syntactic approach}

It is the current standard framework for soundness proofs.
\begin{enumerate}
\item Capture the runtime behavior of the language in a
small-step semantics such that terms with runtime type errors are
\emph{stuck}: Neither are they values, nor can they reduce to
other terms.
\item Demonstrate \emph{progress}: A well-typed term is either a
value or reduces to something else.
\item Demonstrate \emph{preservation}: If a term has type $\tau$
then it continues to have type $\tau$ after one reduction.
\end{enumerate}
Together, progress and preservation imply that well-typed terms
never get stuck, and thus cannot experience runtime type errors.

In most circumstances, we can ``append'' to a syntactic soundness
proof to accommodate new runtime behaviors without modifying
existing arguments. But we cannot take two systems proven sound
by the syntactic approach, take the union of their typing rules,
and expect soundness to hold for the result. The two syntactic
soundness proofs gave us progress and preservation for terms
typed purely with rules in one system; they say nothing about
terms typed with a mixture of rules from both systems.

\Par{The domain-theoretic approach}

\begin{enumerate}
\item Capture the runtime behavior of the language in a domain
equation.
\item Define types as certain sets of values in the semantic
domain. Designate a special value $\Wrong$ for runtime type
errors, and make sure it is not a member of any type.
\item Construct an interpretation from terms to values in the
semantic domain. Show that if a term $t$ has type $\tau$, then
$t$ interprets to a member of $\tau$.
\end{enumerate}
Since no type contains $\Wrong$, well-typed programs do not
denote $\Wrong$, and their evaluation may not encounter runtime
type errors.

A domain-theoretic soundness proof is not extensible with new
runtime behaviors. Adding mutation to a purely functional
language, for example, requires a completely new domain equation.
The old arguments have to be rewritten, because their
foundation---the old domain equation---has become obsolete.

However, if we extend the type system without modifying the
runtime behavior, then we can keep interpreting terms into the
old semantic domain. If the new typing rules are sound on their
own, then they already meet the expectation of the old soundness
proof, namely that they assign type $\tau$ only to terms
interpreting to a member of $\tau$. In this way, the old proof
carries over even to terms typed with a mixture of old and new
rules, and type soundness continues to hold.

If types are pluggable, then the language's runtime behavior has
to stay constant in all possible type systems. In this situation,
a domain-theoretic type soundness proof is more extensible than a
syntactic proof.


\section{Roadmap}

To achieve safely pluggable types, we exploit the extensibility
of domain-theoretic type soundness proofs when the runtime system
never changes. These are the steps:
\begin{enumerate}
\item Choose a semantic domain. For purely functional languages,
a domain for untyped lambda calculus suffices.
\item Choose a theory of types for the semantic domain. We employ
the ideal model by MacQueen, Plotkin and Sethi. It can easily
express \thingsExpressibleInMpsModel.
\item Develop type systems such that each typing rule corresponds
to a true statement in the theory of types. This property often
follows from the domain-theoretic soundness proof and incurs no
effort beyond that.
\end{enumerate}
Thus typing rules become lemmas, judgements become statements,
and typing derivations become proofs. Typing terms with a mixture
of type systems is no more than writing proofs with a larger
collection of lemmas.

The next section discusses domains and the MacQueen-Plotkin-Sethi
model of types on a high level. We will only disclose the
technical details absolutely essential for understanding
pluggable types.

The section after that describes how to make type systems
pluggable.

The other sections give examples of pluggable type systems. We
will look at System~F, unboxed impredicative polymorphism,
optional type arguments, and subtyping.


\section{MacQueen-Plotkin-Sethi model of types}

Outline
\begin{enumerate}
\item domain equation
\item reflexive transitive antisymmetric ordering $\Sub$
\item topology, continuous functions, compact elements
\item rank of elements; every compact element has a finite rank
\item types
\item proximity between types
\item contractive, nonexpansive
\item type constructors: finite union, arbitrary intersection,
recursive
\item why pluggable: MPS says typing's undecidable with any
recursively enumerable set of axioms, so we can only build
conservative approximations. There mayn't be a best
approximation, so it'd be good to mix things up.
\end{enumerate}


\section{Hask-like category of types}

Object = type

Morphism = (function value, domain type, range type)

Show it's a category at all ...

... which is not cartesian closed.

Talk about fmap, fold and generic programming.

btw, existence of unique fixed point for contractive functors
means that initial algebras are final coalgebras whose object is
the fixed point and whose morphism is id. which means lists
\emph{are} streams.



\section{How to craft pluggable types}
\label{howto}

We have learnt the notion of types, the nature of function types,
and the construction of recursive types. We will see how to make
type systems pluggable.

Our core language is untyped lambda calculus with constants. Its
standard denotational semantics serves as the interface to the
runtime system modeled by the value domain $V$. Each lambda term
denotes a value in $V$ under a term environment~$\env$, which is
a partial function mapping variables to values in $V$.

\begin{syntax}
t & ::= & &\mbox{untyped lambda term} \\
& & c &\mbox{constant} \\
&|& x &\mbox{variable} \\
&|& \Abs xt &\mbox{abstraction} \\
&|& t~t &\mbox{application}
\end{syntax}
%
\begin{align*}
\Sem c~\env &= v_c & \mbox{designated value for constant }c\\
\Sem x~\env &= \env(x) & \mbox{variable look-up}\\
\Sem{\Abs x t}~\env &=
\rlap{function mapping $v\in V$ to $\Sem t~(\Update\env{x\mapsto v})$}\\
\Sem{t_1~t_2}~\env &=
\begin{cases}
\bot&\rlap{if $\Sem{t_1}~\env=\bot$}\\
f(v)&\rlap{if $\Sem{t_1}~\env=f\in V\R V$ and $\Sem{t_2}~\env=v$}\\
\Wrong&\rlap{if $\Sem{t_1}~\env\notin \{\bot\}\cup(V\R V)$}
\end{cases}
\end{align*}

A pluggable type system may rely on syntax extensions. Each
extended term must ``erase'' to an untyped lambda term, so that
the runtime knows how to execute it. A syntax extension may be an
optional type annotation, such as one on the argument of a lambda
abstraction.
\begin{syntax}
\sigma & ::= & \cdots & \mbox{type expression}\\
t & \+= & \Abs{x:\sigma}t & \mbox{annotated abstraction}\\
\Erase(\Abs{x:\sigma}t) & = & \Abs x \Erase(t) &
\mbox{erasure to core language}
\end{syntax}

Type expressions have no core syntax; they are not even required
to denote a type. For our purpose of ruling out runtime errors,
it suffices that \emph{some} type expressions denote types. A
type expressions of System~F denotes a type only if it is
\emph{closed}, when all its type variables are universally
quantified somewhere. Table~\ref{corres} on page~\pageref{corres}
contains more examples of type expressions.

Pluggable type systems produce \emph{Judgements.} Judgements are
abbreviations of mathematical statements. To treat statements as
concrete data, we can represent them by well-formed formulas of
ZFC (Zermelo-Fraenkel set theory with the axiom of choice). Each
pluggable type system is free to produce its own flavor of
judgements, but all systems should strive to eventually produce
$J_0$-judgements, or typing judgements about closed terms.
\begin{syntax}
J_0
& ::=
& t : \sigma
   & \mbox{typing judgement about a closed term} \\
&& & \mbox{where $t$ is closed and $\sigma$ denotes a type}
\end{syntax}%
The judgement $t:\sigma$ abbreviates ``The value denoted by $t$
under the empty environment is a member of the type denoted by
$\sigma$.'' We say a closed term $t$ is \emph{well-typed} if the
type system in use can produce some $J_0$-judgement $t:\sigma$.
Since $\Wrong$ is not a member of any type, well-typed
expressions do not denote $\Wrong$.

A pluggable type system produces judgements according to a
collection of \emph{typing rules}. In fact, we can think of the
type system as the collection of typing rules. A typing rule is
an inference rule in the style of natural deduction. Each rule
has zero or more antecedents, zero or more side conditions, and
one conclusion. The antecedents are judgements, the side
conditions are statements (i.~e., well-formed formulas of ZFC),
and the conclusion is a judgement. A typing rule corresponds to
the statement ``If all antecedents and side conditions are true,
then the conclusion is true.'' We call a typing rule \emph{sound}
if it corresponds to a provable statement. Sound typing rules are
admissible with respect to the inference rules of natural
deduction (Does this claim need justification?). The typing rule
in the last row of table~\ref{corres} on page~\ref{corres} is
sound.

Judgements are produced by \emph{derivations.} A derivation is a
natural deduction proof: a finite tree built from instances of
typing rules, where the antecedents of every rule instance
coincide with the conclusions of instances immediately above it,
and all side conditions are true. The final conclusion is the
product of the derivation. If the typing rules are sound, then
the product of every derivation has a proof in ZFC. A pluggable
type system is \emph{sound} if all its typing rules are sound. A
sound type system only produces true judgements.

We mix several type systems together by taking union of their
typing rules. The mixture of sound type systems is clearly sound.
If it produces the $J_0$-judgement $t:\sigma$, then we are
certain that $t$ denotes an element of some type, which cannot be
$\Wrong$. In this sense, mixing pluggable type systems preserves
type safety.

We know a term $t$ never raises runtime type errors if some
typing derivation produces a $J_0$-judgement about $t$. It does
not matter how the typing derivation is produced. A practical
implementation of a pluggable type system may be incomplete
without compromising type safety. The type checker may reject
some terms by mistake and loop forever on others, but the terms
it does accept are guaranteed to be type safe. Since the type
system is extensible, writing code with an incomplete type
checker will not create maintenance hell in the future. The user
can start using a type system without waiting for its type
checker to become complete and decidable.



\section{Warm-up example: System~F}

We will phrase System~F in the framework outlined in
\S\ref{howto} so that it can be used together with other type
systems. This particular semantic model of System~F was outlined
in Girard (System~F of variable types: fifteen years later,
\S3.1).

\Par{Syntax extension}

System~F requires annotated abstraction, type abstraction and
type application. The interpretation of any term with these
extensions is identical to the interpretation of its erasure.

\begin{syntax}
t &\+=& &\mbox{syntax extension} \\
&& \Abs{x:\sigma}t &\mbox{annotated abstraction}\\
&|& \Tabs\alpha t &\mbox{type abstraction}\\
&|& t~[\sigma] &\mbox{type application}
\end{syntax}%

\begin{align*}
\Erase(\Abs{x:\sigma}t) & = \Abs x\Erase(t) \\
\Erase(\Tabs\alpha t) &= \Erase(t) \\
\Erase(t~[\sigma]) &= \Erase(t)
\end{align*}

\Par{Type expressions}

\begin{syntax}
\sigma &::=& &\mbox{open type expression}\\
&& \iota &\mbox{base type}\\
&|& \alpha &\mbox{type variable}\\
&|& \sigma\R\sigma &\mbox{function type}\\
&|& \All\alpha\sigma &\mbox{universal type}
\end{syntax}%

\Par{Interpretation of open types}

A type environment $\Env$ is a \emph{total}%
%
\footnote{%
If we allowed type environments to be undefined on some type
variables, then many typing judgements would have to begin with
``for every type environment defined on all relevant free type
variables.''
%
} %
function mapping type variables to types.
An open type denotes a partial function mapping type environments
to types.

\begin{align*}
\Sem\iota~\Env &= T_\iota \subseteq B\hspace{2cm}\mbox{designated base type}\\
\Sem\alpha~\Env &= \Env(\alpha)\\
\Sem{\sigma_0\R\sigma_1}~\Env &= (\Sem{\sigma_0}~\Env)\ \RT\ (\Sem{\sigma_1}~\Env)\\
&=\{\bot\}\cup\{f\in V\R V\Or f(\Sem{\sigma_0}~\Env)\subseteq\Sem{\sigma_1}~\Env\}\\
\Sem{\All\alpha\sigma}~\Env &=
\bigcap_{T\in\Type} \Sem\sigma~(\Update\Env{\alpha\mapsto T})
\end{align*}

If an open type expression $\sigma$ has no free type variable,
then we say $\sigma$ is \emph{closed} and denotes the
type~$\Sem\sigma~\Env_\bot$, where $\Env_\bot$ is the type
environment mapping every type variable to $\{\bot\}$.


\Par{Judgements}

\begin{syntax}
\Gamma &::=&& \mbox{typing context}\\
&& \emptyset &\mbox{empty context}\\
&|&\Gamma,x:\sigma &\mbox{term variable binding}\\
\\\\
\JF &::=
&\Gamma\vdash t:\sigma
& \mbox{F-judgement}
\end{syntax}


\Par{Interpretion of F-judgements}

Write
\[
\Sem\Gamma~\Env =
\{
\env\Or
\env(x)\in\Sem\sigma~\Env\text{ for all }
x:\sigma\in\Gamma
\}.
\]
If $\env\in\Sem\Gamma~\Env$, then we say that the term
environment $\env$ is \emph{compatible} with the typing context
$\Gamma$ under the type environment $\Env$.

The F-judgement $\Gamma\vdash t:\sigma$ abbreviates the
following statement.
\begin{quotation}
For every type environment $\Env$ and every $\env\in\Sem\Gamma~\Env$,
\[
\Sem{t}~\env~\in~\Sem\sigma~\Env.
\]
\end{quotation}~


\Par{Typing rules of Pluggable~F}~

\infrule[T-0]
{\emptyset\vdash t:\sigma\andalso t,\sigma\text{ closed}}
{t:\sigma}

\infrule[T-Con]
{v_c\in \Sem\sigma~\emptyset\andalso\sigma\text{ closed}}
{\Gamma\vdash c:\sigma}

\infrule[T-Var]
{x:\sigma\in\Gamma}
{\Gamma\vdash x:\sigma}

\infrule[T-Abs]
{\Gamma,x:\sigma_1\vdash t:\sigma_2
\andalso x\notin\Gamma}
{\Gamma\vdash\Abs{x:\sigma}t : \sigma_1\R\sigma_2}

\infrule[T-App]
{\Gamma\vdash t_1:\sigma_2\R\sigma_3
\andalso\Gamma\vdash t_2:\sigma_2}
{\Gamma\vdash t_1~t_2:\sigma_3}

\infrule[T-Tabs]
{\Gamma\vdash t:\sigma\andalso\alpha\notin\FTV(\Gamma)}
{\Gamma\vdash\Tabs\alpha t:\All\alpha\sigma}

\infrule[T-Tapp]
{\Gamma\vdash t:\All\alpha\sigma_0}
{\Gamma\vdash t~[\sigma_1]:\sigma_0[\alpha\mapsto\sigma_1]}


\Par{Soundness of Pluggable~F}

We outline the proof of each statement corresponding to a typing
rule of Pluggable~F.

\textsc{T-0}: Since $t$ and $\sigma$ are closed, they denote a
value $v_t$ and a type $T_\sigma$ under whatever environments.
The antecedent says $v_t\in T_\sigma$; the conclusion says the
same thing.

\textsc{T-Con}: Since $c$ and $\sigma$ are both closed, their
denotations do not depend on type or term environments. The
conclusion is a consequence of the first side condition.

\textsc{T-Var}: The
side condition implies that no matter which term environment
$\env$ compatible with $\Gamma$ is chosen, the value $\env(x)$
must be a member of the type $\Sem\sigma~\Env$. The conclusion
follows.

\textsc{T-Abs}: Write $T_1=\Sem{\sigma_1}~\Env$ and
$T_2=\Sem{\sigma_2}~\Env$. By the antecedent, $t$ denotes a value
in $T_2$ under every environment $\env$ that is compatible with
$\Gamma$ and maps $x$ to a member of $T_1$. It follows that the
denotation of $\Abs xt$ under every environment compatible with
$\Gamma$ is a function whose image of $T_1$ is a subset of $T_2$.

\textsc{T-App}: The antecedents say that under every
compatible environment, $t_1$ denotes a function $f$ whose image
of $\Sem{\sigma_2}~\Env$ is a subset of $\Sem{\sigma_3}~\Env$,
and $t_2$ denotes a value $v\in\Sem{\sigma_2}~\Env$. As desired,
$f(v)\in\Sem{\sigma_3}~\Env$.

\textsc{T-Tabs}: Let $\env$ be an arbitrary term environment
compatible with $\Gamma$ under $\Env$. Let $v=\Sem{t}~\env$.
For every type $T\in\Type$, the antecedent guarantees that
\[
v\in\Sem\sigma~(\Update\Env(\alpha\mapsto T)),
\]
which implies
\[
v\in\bigcap_{T\in\Type}\Sem\sigma~(\Update\Env(\alpha\mapsto T))
=\Sem{\All\alpha\sigma}~\Env.
\]

\textsc{T-Tapp}: Let $\env$ be a term environment compatible with
$\Gamma$ under $\Env$. Write
\begin{align*}
T_1&=\Sem{\sigma_1}~\Env,\\
v&=\Sem{t}~\env.
\end{align*}
By the antecedent,
\[
v\in
\bigcap_{T\in\Type}\Sem{\sigma_0}~(\Update\Env(\alpha\mapsto T))
\ \subseteq\ \Sem{\sigma_0}~(\Update\Env\alpha\mapsto T_1).
\]
By the correctness of capture-avoiding substitution,
\[
\Sem{\sigma_0}~(\Update\Env\alpha\mapsto T_1)
=
\Sem{\sigma_0[\alpha\mapsto\sigma_1]}~\Env,
\]
which gives us $v\in\Sem{\sigma_0[\alpha\mapsto\sigma_1]}~\Env$
as desired.


\section{Constrained type system version 1}

To demonstrate what pluggable types are possible, we present a
novel type system CT1 (Constrained Type System Version 1). It
supports the impredicative universal types of System~F, but does
not demand type arguments from the user. The metatheory of CT1 is
far from mature. We do not know whether it can type all
well-typed System~F terms with type applications erased, or
whether it has a terminating type checking algorithm. Since CT1
is pluggable, however, we can start reaping the benefit of CT1
without waiting for metatheoretic development. If it so happened
that CT1 could not handle certain useful programs, then we would
simply import a new type system to deal with those, confident
that any legacy code typed under CT1 will continue to enjoy
strong type soundness.

\Par{Syntax extension}

\begin{syntax}
t &\+=& \Abs{x:\sigma}t &\mbox{annotated abstraction}\\
&|& \Tabs\alpha t &\mbox{type abstraction}
\end{syntax}%

\begin{align*}
\Erase(\Abs{x:\sigma}t) & = \Abs x\Erase(t)\\
\Erase(\Tabs\alpha t) &= \Erase(t)
\end{align*}

\Par{Type expressions}

CT1 requires the open types of System~F under the same
interpretation. In addition, CT1 has interval-bounded universal
types, which represents the solution of a set of constraints.

\begin{syntax}
\sigma &::=& &\mbox{open type expression}\\
&& \iota &\mbox{base type}\\
&|& \alpha &\mbox{type variable}\\
&|& \sigma\R\sigma &\mbox{function type}\\
&|& \All\alpha\sigma &\mbox{universal type}\\
\\\\
\sigma_\cup &::=& &\mbox{finite union type}\\
&|& \Bot &\mbox{union of 0 types}\\
&|& \sigma \cup \sigma_\cup &\mbox{union of $n+1$ types}\\
\\\\
\sigma_\cap &::=& &\mbox{finite intersection type}\\
&|& \Top &\mbox{intersection of 0 types}\\
&|& \sigma \cap \sigma_\cap &\mbox{intersection of $n+1$ types}\\
\\\\
I &::=& [\sigma_\cup, \sigma_\cap] &\mbox{type interval}\\
\\\\
\rho &::=& &\mbox{left type (%
\begin{otherlanguage}{greek}αριστερά\end{otherlanguage}
)}\\
&|& \sigma &\mbox{open type}\\
&|& \All{\alpha\in I}\rho &\mbox{interval-bounded universal type}
\end{syntax}%

\Par{Interpretation of type expressions}
\label{interp-ct-types}

Finite union and intersection type expressions have the same
interpretation as open types. Recall that the union of two types
is a type.
\begin{align*}
\Sem\Bot~\Env &=\{\bot\}\\
\Sem{\sigma\cup\sigma_\cup}~\Env &= (\Sem\sigma~\Env) \cup
(\Sem{\sigma_\cup}~\Env)\\
\Sem\Top~\Env &=V-\{\Wrong\}\\
\Sem{\sigma\cap\sigma_\cap}~\Env &= (\Sem\sigma~\Env) \cap
(\Sem{\sigma_\cap}~\Env)
\end{align*}
A type interval interprets to a set of types sandwiched between
its lower and upper bounds. If the lower bound is not a subset of
the upper bound, then the type interval interprets to the empty
set.
\begin{align*}
\Sem{[\sigma_\cup,\sigma_\cap]}~\Env &= \{T\in\Type\Or
\Sem{\sigma_\cup}~Env\ \subseteq\ T\ \subseteq\ \Sem{\sigma_\cap}~Env\}
\end{align*}
An interval-bounded universal type $\rho$ interprets to the
intersection of a family of types indexed by types in the
interval.
\begin{align*}
\Sem{\All{\alpha\in I}\rho}~\Env &=
\begin{cases}
\displaystyle\bigcap_{T\in(\SemSlim I~\Env)}
\Sem\rho~(\Update\Env\alpha\mapsto T)&\text{if}\quad\Sem I~\Env\neq\emptyset\\[2em]
\mbox{undefined}&\text{if}\quad\Sem I~\Env=\emptyset
\end{cases}
\end{align*}

\Par{Judgements}

CT1 produces two species of judgements. The S-judgements are
about relative containment between types, and the CT-judgements
are conditional statements about the membership of values in
types. Typing contexts are identical to those in System~F.

\begin{syntax}
\Gamma &::=&\emptyset& \mbox{typing context}\\
&|&\Gamma,x:\sigma\\
\\\\
E & ::= & \emptyset & \mbox{prefix of interval bounds}\\
&|&E,\alpha\in I\\
\\\\
C & ::= & \emptyset & \mbox{subtype constraints}\\
&|& C,\rho\le\sigma\\
\\\\
\JCT & ::= & \Gamma\vdash t:\sigma\Given C
&\mbox{CT-judgement}\\
\\\\
\JS & ::= & E\vdash C & \mbox{S-judgement}
\end{syntax}

\Par{Interpretation of CT-judgements}
A type environment $\Env$ satisfies the list of constraints $C$
if for each $\rho_i\le\sigma_i\in C$,
\[
\Sem{\rho_i}~\Env\ \subseteq\ \Sem{\sigma_i}~\Env
\]

The CT-judgement $\Gamma\vdash t:\sigma\Given C$ abbreviates:
\begin{quotation}
For every $\Env$ satisfying $C$ and every
$\env\in\Sem\Gamma~\Env$,
\[
\Sem t~\env\ \in\ \Sem\sigma~\Env.
\]
\end{quotation}

Let $E=\beta_1\in I_1,\ldots,\beta_n\in I_n$ be an arbitrary
prefix of interval bounds. A type environment $\Env$ is
\emph{compatible} with $E$ if for all $1\le j\le n$ we have
\[
\Env(\beta_j)\ \in\ \Sem{I_j}~\Env.
\]
(See \S\ref{interp-ct-types} for the meaning $\Sem{I_j}~\Env$ of
the type interval. Note that $\Env$ appears on both sides of the
equation.)

Define \emph{well-formed prefixes} recursively thus:
\begin{itemize}
\item $\emptyset$ is well-formed.
\item If $E$ is well-formed, $\alpha$ is a fresh type variable,
and $\Sem I~\Env\neq\emptyset$ for every $\Env$ compatible with
$E$, then $E,\alpha\in I$ is well-formed.
\end{itemize}


\begin{samepage}
The S-judgement $E\vdash C$ abbreviates:
\begin{quotation}
$E$ is well-formed. Every $\Env$ compatible with $E$ satisfies $C$.
\end{quotation}
\end{samepage}


\Par{Constrained typing rules of CT1}~

% handle top-level sigs by type ascription in next section
% no need for sub0 here
\infrule[CT-0]
{\emptyset\vdash t:\sigma\Given\emptyset\andalso
t,\sigma\text{ closed}}
{t:\sigma}

\infrule[CT-Var]
{x:\sigma\in\Gamma}
{\Gamma\vdash x:\sigma\Given\emptyset}

\infrule[CT-Abs]
{\Gamma,x:\sigma_1\vdash t:\sigma_2\Given C
\andalso x\notin\Gamma}
{\Gamma\vdash\Abs{x:\sigma}t : \sigma_1\R\sigma_2\Given C}

\infrule[CT-App]
{\Gamma\vdash t_1:\sigma_1\Given C_1
\andalso\Gamma\vdash t_2:\sigma_2\Given C_2
\andalso\alpha,\beta\text{ fresh}
}
{\Gamma\vdash t_1~t_2:\beta
\Given C_1\cup C_2,\sigma_1\le\alpha\R\beta,\sigma_2\le\alpha
}

\infrule[CT-Tabs]
{
\Gamma\vdash t:\sigma\Given C
\andalso
\beta_1\in I_1,\ldots,\beta_n\in I_n\vdash C
\andalso
\alpha,\beta_1,\ldots,\beta_n\notin\FTV(\Gamma)
}
{\Gamma\vdash\Tabs\alpha t :
\All\alpha\All{\beta_1\in I_1}\cdots\All{\beta_n\in I_n}\sigma
\Given\emptyset}

\Par{Soundness of constrained typing rules of CT1}

We outline the proof of each statement corresponding to a
constrained typing rule of CT1.

\textsc{CT-0}: Since $t$ and $\sigma$ are closed, they denote a
value $v$ and a type $T$ under whatever environments. The
antecedent states that $v\in T$ under a vacuously true condition,
so we may conclude $v\in T$.

\textsc{CT-Var}: The conclusion follows from the definition of
environments compatible with $\Gamma$.

\textsc{CT-Abs}: Let $\Env$ be a type environment satisfying $C$.
If $\Env$ does not exist, then the conclusion is vacuously true.
If $\Env$ exists, then let $\env$ be compatible with $\Gamma$
under $\Env$. Write
\begin{align*}
T_1&=\Sem{\sigma_1}~\Env,\\
T_2&=\Sem{\sigma_2}~\Env,\\
f&=\Sem{\Abs x t}~\env.
\end{align*}
Choose arbitrary $v\in T_1$. Since $(\Update\env x\mapsto v)$ is
compatible with $\Gamma,x:\sigma_1$, the antecedent yields
$f(v)\in T_2$, and we may conclude $f\in T_1 \RT T_2$.

\textsc{CT-App}: Let $\Env$ be a type environment satisfying
$C_1\cup C_2,\sigma_1\le\alpha\R\beta,\sigma_2\le\alpha$. Choose
arbitrary $\env\in\Sem\Gamma~\Env$. Write
\begin{align*}
T_1&=\Sem{\sigma_1}~\Env,&
v_1&=\Sem{t_1}~\env,\\
T_2&=\Sem{\sigma_2}~\Env,&
v_2&=\Sem{t_2}~\env.
\end{align*}
Since $\Env$ satisfies $\sigma_1\le\alpha\R\beta$ and
$\sigma_2\le\alpha$,
\begin{align*}
T_1&\subseteq \Env(\alpha)\RT\Env(\beta), &
T_2&\subseteq \Env(\alpha).
\end{align*}
Since $\Env$ satisfies both $C_1$ and $C_2$, the antecedents give
us
\begin{align*}
v_1&\in T_1 \subseteq \Env(\alpha)\RT\Env(\beta), &
v_2&\in T_2 \subseteq \Env(\alpha),
\end{align*}
which allows us to conclude $v_1(v_2)\in\Env(\beta)$.

\textsc{CT-Tabs}: The assumed S-judgement $\beta_1\in
I_1,\ldots,\beta_n\in I_n\vdash C$ states two things: that
\[
E=\beta_1\in I_1,\ldots,\beta_n\in I_n
\]
is well-formed, and that every type environment compatible with
$E$ satisfies $C$. By the antecedent
\[
\Gamma\vdash t:\sigma\Given C,
\]
we know that for each $\Env$ compatible with $E$ and each
$\env\in\Sem\Gamma~\Env$,
\[
\Sem t~\env\in \Sem\sigma~\Env.
\]
Now consider an arbitrary type environment $\Env'$. Let
\begin{align*}
T&=\Sem{\All\alpha\All{\beta_1\in I_1}\cdots\All{\beta_n\in I_n}\sigma}~\Env'\\
&=
\bigcap_{T_\alpha\in\Type\quad}
\bigcap_{T_1\in\Sem{I_1}~(\alpha\mapsto T_\alpha)}
\cdots
\bigcap_{T_n\in\Sem{I_n}~(\alpha\mapsto T_\alpha,\beta_1\mapsto T_1,\ldots)}
\\
&\hspace{1.5cm}
\Sem\sigma~(\alpha\mapsto
T_1,\beta_1\mapsto T_1,\ldots,\beta_n\mapsto T_n).
\end{align*}

TODO FIXME: define $\Env_n$ inductively and take apart the
monstrosity above.


\Par{Subtyping rules of CT1}~

\infrule[S-Vacuous]
{}
{\emptyset\vdash\emptyset}

\infrule[S-Refl]
{E\vdash C}
{E\vdash C,\sigma\le\sigma}

\infrule[S-Arrow]
{E\vdash C, \sigma_2\le\sigma_0,\sigma_1\le\sigma_3}
{E\vdash C, \sigma_0\R\sigma_1\le\sigma_2\R\sigma_3}

\infrule[S-Union]
{E\vdash C, \sigma_1\le\sigma_3,\sigma_2\le\sigma_3}
{E\vdash C, \sigma_1\cup\sigma_2\le\sigma_3}

\infrule[S-Intersect]
{E\vdash C, \sigma_1\le\sigma_2,\sigma_1\le\sigma_3}
{E\vdash C, \sigma_1\le\sigma_2\cap\sigma_3}

\infrule[S-L0]
{
E,\alpha\in I\vdash C, \sigma_1\le\sigma_2
\andalso
\text{$\alpha$ occurs only in $\sigma_1$}
}
{E\vdash C, (\All\alpha\sigma_1)\le\sigma_2}

\infrule[S-L1]
{
E,\alpha\in [\sigma_3\cup\sigma_4,\sigma_5\cap\sigma_6]\vdash
C, \sigma_1\le\sigma_2
\andalso
\text{$\alpha$ occurs only in $\sigma_1$}
}
{E\vdash C, (\All{\alpha\in [\sigma_3,\sigma_5]}\sigma_1)\le\sigma_2}

\infrule[S-R]
{
E\vdash C,\sigma_1\le\sigma_2
\andalso
\text{$\alpha$ occurs only in $\sigma_2$}
}
{E\vdash C, \sigma_1\le(\All\alpha\sigma_2)}


\infrule[S-Loner]
{
\begin{array}[b]{r@{\;}l}
E&\vdash C\cup
\{\sigma_i\le\sigma_j\Or-m\le i\le-1\text{ and }1\le j\le n\}
\\
I&=[\sigma_{-m}\cup\cdots\cup\sigma_{-1},\sigma_1\cap\cdots\cap\sigma_n]
\end{array}
\andalso
\text{$\alpha$ fresh}
}
{E,\alpha\in I\vdash C,
\sigma_{-m}\le\alpha,\ldots,\sigma_{-1}\le\alpha,
\alpha\le\sigma_2,\ldots,\alpha\le\sigma_n
}


\Par{Soundness of subtyping rules of CT1}


\section{Mixing F and CT1 for optional type arguments}

Look at all those syntactic extensions. Isn't this an awesome
opportunity for some solutions to the expression problem?


\section{Parametric types}

It may be possible to refine ``equal up to termination'' relation
in ``fast and loose reasoning'' to the non-transitive consistency
relation. Free theorems should hold. Parametric types are not
universal types.


\input{appendix.tex}
\end{document}
