% latex
\documentclass{amsart}
\usepackage{bcprules}
\title
[Impredicative type inference]
{
Impredicative type inference
\break
or
\break
partial proof reconstruction \break
for a fragment of \break
second-order classical logic
}

\let\phi=\varphi % default phi looks like empty set
\allowdisplaybreaks
\swapnumbers
\newtheorem{lemma}[subsection]{Lemma}

\begin{document}
\newcommand{\nc}{\newcommand}
\newcommand{\DotExpr}[2]{#1 #2.\ }
\nc\Abs   {\DotExpr\lambda}
\nc\All   {\DotExpr\forall}
\nc\Bro   {\operatorname{Brouwer}}
\nc\CallCC{\operatorname{call/cc}}
\nc\Case  {}
\nc\Cps   {\operatorname{cps}}
\nc\Dn [1]{(#1 \R \bot) \R \bot}
\nc\Dni   {\mathrm{\neg\neg I}}
\nc\Ex    {\DotExpr\exists}
\nc\FV    {\operatorname{FV}}
\nc\Id    {\mathit{id}}
\nc\Indent{\hspace{3em}}
\nc\Mgs   {\operatorname{mgs}}
\nc\Or    {\ | \ }
\nc\Prune {\operatorname{prune}}
\nc\Recall{\DotExpr\Xi} % looks like âˆƒ
\nc\Redo  {\operatorname{redo}}
\nc\Tabs  {\DotExpr\Lambda}
\nc\R     {\rightarrow}
\nc\Undo  {\operatorname{undo}}
\nc\Unify {\operatorname{unify}}
\maketitle
\tableofcontents

\section{Classical F}

\subsection{Grammar of classical F}

\nc\Ftype{
\tau & ::= & \alpha & \mbox{type variable} \\
&\Or& \tau \rightarrow \tau & \mbox{function type} \\
&\Or& \All\alpha\tau & \mbox{universal type} \\
}

\nc\CFtype{
\Ftype
&\Or& \Ex\alpha\tau & \mbox{existential type} \\
}

\nc\CFterm{
t & ::= & x & \mbox{variables} \\
&\Or& \Abs{x:\tau}t  & \mbox{lambda abstraction} \\
&\Or& \ t~t & \mbox{function application} \\
}

\nc\SelectiveTypeAmnesia{
&\Or& t~\{\Ex\alpha\tau\} & \mbox{selective type amnesia} \\
}

\nc\TypingContexts{
\Gamma & ::= & \Gamma, x : \tau & \mbox{term variable binding}\\
&\Or& \Gamma, \alpha& \mbox{type variable binding} \\
&\Or& \epsilon & \mbox{empty context}\\ \\
}

\[
\begin{array}{lclr}
% types
\CFtype
\\
% terms
\CFterm
&\Or& \Tabs\alpha t & \mbox{cosmetic type abstraction} \\
\SelectiveTypeAmnesia
\\
% contexts
\TypingContexts
\end{array}
\]

\subsection{Typing of classical F}
~

\nc\Tautology{
\infrule[Taut]
{x : \tau \in \Gamma}
{\Gamma \vdash x : \tau}
}

\nc\UniversalIntroduction{
\infrule[$\forall$I]
{\Gamma,\alpha \vdash t:\tau
  \andalso \alpha \notin \Gamma}
{\Gamma \vdash (\Tabs\alpha t) : \All\alpha\tau}
}

\nc\ExistentialIntroduction{
\infrule[$\exists$I]
{\Gamma \vdash t : \tau[\alpha\mapsto\sigma]}
{\Gamma \vdash t~\{\Ex\alpha\tau\} : \Ex\alpha\tau}
}

\nc\UniversalNegation{
\infrule[$\neg\forall$]
{\Gamma \vdash t : (\All\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \Ex\alpha \sigma \R \tau}
}

\nc\ExistentialNegation{
\infrule[$\neg\exists$]
{\Gamma \vdash t : (\Ex\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \All\alpha \sigma \R \tau}
}

\nc\SuperIntroduction{
\infrule[$\R\forall$I]
{\Gamma, A, x:\sigma \vdash t : \tau
  \andalso A = \FV(\sigma) - \Gamma}
{\Gamma \vdash (\Abs{x:\sigma}t) : \All A{\sigma\R\tau}}
}

\nc\SuperElimination{
\infrule[$\R\forall\exists$E]
{\Gamma \vdash s : \All{A_s} \Ex{E_s} \sigma_s \R \tau
  \andalso \Gamma \vdash t : \All{A_t} \Ex{E_t} \sigma_t \\
  A = A_s \uplus A_t \andalso E = E_s \uplus E_t \\
  \Unify(A, E, \sigma_s, \sigma_t) \downarrow \Mgs}
{\Gamma \vdash s~t : \Prune(\All A \Ex E \Mgs(\tau))}
}

\Tautology

\UniversalNegation

\ExistentialNegation

\SuperIntroduction

\SuperElimination

Pruning removes redundant quantifiers, i.~e., those who bind
names that never occur free in their scopes. Unification is
discussed in section~\ref{sec:unify}.

\UniversalIntroduction

\ExistentialIntroduction

\section{Classical call/cc calculus}

\subsection{Grammar of classical call/cc calculus}

\nc\Fterm{
\CFterm
&\Or& \Tabs\alpha t & \mbox{type abstraction} \\
&\Or& t~[\tau] & \mbox{type application} \\
}

\[
\begin{array}{lclr}
% types
\Ftype
&\Or& \Ex\alpha\tau & \mbox{existential type} \\
&\Or& \bot & \mbox{result type of continuations} \\
\\
% terms
\Fterm
\SelectiveTypeAmnesia
&\Or& \Recall\alpha t & \mbox{deferred type remembrance} \\
&\Or& \CallCC~t & \mbox{call with current continuation} \\
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of classical call/cc calculus}
~

\nc\UniversalElimination{
\infrule[$\forall$E]
{\Gamma \vdash t : \All\alpha\tau
   \andalso \FV(\sigma)\subseteq \Gamma}
{\Gamma \vdash t~[\sigma] : \tau[\alpha\mapsto\sigma]}
}

\nc\FRules{
\Tautology
%
\infrule[$\R$I]
{\Gamma,x:\sigma \vdash t : \tau
  \andalso \FV(\sigma) \subseteq \Gamma}
{\Gamma \vdash (\Abs{x:\sigma}t) : \sigma\R\tau}
%
\infrule[$\R$E]
{\Gamma\vdash s:\sigma\R\tau
  \andalso \Gamma\vdash t:\sigma}
{\Gamma\vdash s~t:\tau}
%
\UniversalIntroduction
%
\UniversalElimination
}

\nc\ExistentialElimination{
\infrule[$\exists$E]
{\Gamma,\alpha \vdash t:\sigma\R\tau
  \andalso \alpha \notin \Gamma
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash (\Recall\alpha t):(\Ex\alpha\sigma)\R\tau}
}

\nc\DoubleNegationElimination{
\infrule[$\neg\neg$E]
{\Gamma \vdash t : \Dn{\tau}}
{\Gamma \vdash \CallCC~t : \tau}
}

\FRules

\ExistentialIntroduction

\ExistentialElimination

\DoubleNegationElimination

\section{System F}

\subsection{Grammar of system F}

\[
\begin{array}{lclr}
\Ftype
&\Or& \bot & \mbox{bottom type} \\
\\
\Fterm
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of system F}
~

\FRules

\subsection{Useful terms of system F}

\begin{align*}
\Dni & : \All\alpha \alpha \R (\Dn\alpha) \\
\Dni & = \Tabs\alpha \Abs{x:\alpha}
           \Abs{c : (\alpha \R \bot)} c~x
\end{align*}

\begin{align*}
\Bro & : \All\alpha (\Dn{(\alpha\R\bot)}) \R (\alpha \R \bot) \\
\Bro & = \Tabs\alpha \Abs{f:(\Dn{(\alpha\R\bot)})}
           \Abs{x:\alpha} f~(\Dni~[\alpha]~x)
\end{align*}

\subsection{Embedding classical call/cc calculus in system F}

Due to Curry-Howard correspondence, the embedding of classical
call/cc calculus in system F can be viewed from either a
logical or a programming perspective.
\begin{itemize}
\item From the logical point of view, the embedding is an
instance of Kolmogorov's negative translation from classical
logic to intuitionistic logic.
\item From the programming point of view, the embedding is a
continuation-passing-style transformation that gets rid of
$\CallCC$ and existential types.
\end{itemize}
If $\tau$ is a type in classical call/cc calculus, then $\tau^K$
shall be the corresponding type in system F. It is a similar
correspondence between contexts $\Gamma$ and $\Gamma^K$, or
between terms $t$ and $t^K$. The aforementioned embedding
transforms typing judgements in the classical calculus to typing
judgements in F. We shall call it ``$\Cps$''.

\begin{align*}
\alpha^K & =
  \Dn\alpha
  \\
(\sigma \R \tau)^K & =
  \Dn{(\sigma^K \R \tau^K)}
  \\
(\All\alpha\tau)^K & =
  \Dn{(\All\alpha\tau^K)}
  \\
(\Ex\alpha\tau)^K & =
  (\All\alpha \tau^K \R \bot) \R \bot
  \\
\bot^K & =
  \Dn\bot
\end{align*}

\begin{align*}
(\Gamma, x:\tau)^K & =
  \Gamma^K, x:\tau^K
  \\
(\Gamma, \alpha)^K & =
  \Gamma^K, \alpha
  \\
\epsilon^K & =
  \epsilon
\end{align*}

% cps: tautology
\begin{align*}
\Cps(\Gamma \vdash x : \tau) & =
  \Gamma^K \vdash x : \tau^K
\end{align*}

% cps: implication introduction
\begin{align*}
\Cps(\Gamma \vdash (\Abs{x:\sigma}t) : \sigma \R \tau) & =
  \Gamma^K \vdash (\Abs{x:\sigma}t)^K : \Dn{(\sigma^K \R \tau^K)} &
  \mbox{where}
  \\
\Gamma^K,x:\sigma^K \vdash t^K : \tau^K & =
  \Cps(\Gamma,x:\sigma \vdash t : \tau)
  \\
(\Abs{x:\sigma}t)^K & =
  \Abs{c : ((\sigma^K \R \tau^K) \R \bot)}c~(\Abs{x : \sigma^K} t^K)
\end{align*}

% cps: implication elimination
\begin{align*}
\Cps(\Gamma \vdash s~t : \tau) & =
  \Gamma^K \vdash (s~t)^K : \tau^K
  & \mbox{where}
  \\
\Gamma^K \vdash s^K : \Dn{(\sigma^K \R \tau^K)} & =
  \Cps(\Gamma \vdash s : \sigma \R \tau)
  \\
\Gamma^K \vdash t^K : \sigma^K & =
  \Cps(\Gamma \vdash t : \sigma)
  \\
\rho \R \bot & = \tau^K
  \\
(s~t)^K & =
  \Abs{c : \rho} s^K~(\Abs{f : \sigma^K \R \rho \R \bot} \\
  &\Indent t^K~(\Abs{x : \sigma^K} f~x~c))
\end{align*}

% cps: universal introduction
\begin{align*}
\Cps(\Gamma \vdash (\Tabs\alpha t) : \All\alpha \tau) & =
  \Gamma^K \vdash (\Tabs\alpha t)^K : \Dn{(\All\alpha \tau^K)}
  & \mbox{where}
  \\
\Gamma^K,\alpha \vdash t^K : \tau^K & =
  \Cps(\Gamma,\alpha \vdash t : \tau)
  \\
(\Tabs\alpha t)^K & =
  \Abs{c : ((\All\alpha \tau^K) \R \bot)}c~(\Tabs\alpha \tau^K)
\end{align*}

% cps: universal elimination
\begin{align*}
\Cps(\Gamma \vdash t~[\sigma] : \tau[\alpha\mapsto\sigma]) & =
  \Gamma^K \vdash (t~[\sigma])^K :
  \Dn{\tau_1}
  & \mbox{where}
  \\
\Gamma^K \vdash t^K : \Dn{(\All\alpha \tau^K)} & =
  \Cps(\Gamma \vdash t : \All\alpha \tau)
  \\
\tau_1 & = \tau^K[(\Dn\alpha) \mapsto \sigma^K]
  \\
\tau_2 & = \tau^K[\alpha \mapsto \sigma^K]
  \\
\rho \R \bot & = \sigma^K
  \\
 (t~[\sigma])^K & =
  \Abs{c : (\tau_1 \R \bot)} t^K~(\Abs{x : (\All\alpha\tau)} \\
  &\Indent
  c~\Undo_{\alpha,\rho}(x~[\sigma^K], \tau))
\end{align*}

% cps: existential introduction
\begin{align*}
\Cps(\Gamma \vdash t~\{\Ex\alpha\tau\} : \Ex\alpha\tau) & =
  \Gamma^K \vdash (t~\{\Ex\alpha\tau\})^K :
  (\All\alpha \tau^K \R \bot) \R \bot
  & \mbox{where}
  \\
\Gamma^K \vdash t^K : \tau_1 & =
  \Cps(\Gamma \vdash t : \tau[\alpha \mapsto \sigma])
  \\
\tau_1 & = \tau^K[(\Dn\alpha)\mapsto\sigma^K]
  \\
\tau_2 & = \tau^K[\alpha\mapsto\sigma^K]
  \\
\rho \R \bot & = \sigma^K
  \\
 (t~\{\Ex\alpha\tau\})^K & =
  \Abs{c : (\All\alpha \tau^K \R \bot)}
  c~[\sigma^K]~\Redo_{\alpha,\rho}(t^K,\tau)
\end{align*}

% cps: existential elimination
\begin{align*}
\Cps(\Gamma \vdash (\Recall\alpha t) :
    (\Ex\alpha\sigma) \R \tau) & =
  \Gamma^K \vdash (\Recall\alpha t)^K :
      ((\Ex\alpha\sigma) \R \tau)^K
  \qquad \mbox{where}
  \\
\Gamma^K,\alpha \vdash t^K : \Dn{(\sigma^K\R\tau^K)} & =
  \Cps(\Gamma,\alpha \vdash t : \sigma \R \tau)
  \\
((\Ex\alpha\sigma) \R \tau)^K & =
  \Dn{( ((\All\alpha \sigma^K \R \bot)\R\bot) \R \tau^K)}
  \\
\rho \R \bot & = \tau^K
  \\
(\Recall\alpha t)^K & =
  \Abs{c:(((\All\alpha \sigma^K\R\bot)\R\bot)\R\tau^K)\R\bot} \\
  &\Indent c~(\Abs{x : ((\All\alpha \sigma^K\R\bot)\R\bot)}
    \Abs{y : \rho} \\
  &\Indent\hspace{1em}
    x~(\Tabs\alpha \Abs{z : \sigma^K} \\
  &\Indent\hspace{2em}
    t^K~(\Abs{f : \sigma^K \R \tau^K}
      f~z~y
  )))
\end{align*}

% cps: call/cc
\begin{align*}
\Cps(\Gamma \vdash \CallCC~t : \tau) & =
  \Gamma^K \vdash (\CallCC~t)^K : \tau^K
  &\mbox{where}
  \\
\Gamma^K \vdash t^K : \rho & =
  \Cps(\Gamma \vdash t : \Dn\tau)
  \\
\rho & =
  (((((\tau^K \R \bot^K) \R\bot)\R\bot)
    \R \bot^K) \R\bot)\R\bot
  \\
\bot^K & = \Dn\bot
  \\
(\CallCC~t)^K & =
  \Abs{c : \tau^K \R \bot}
  \\ &\Indent
  t^K~(\Abs{f : (\Dn{(\tau^K\R\bot^K)}) \R \bot^K}
  \\ &\Indent\Indent
  f~(
  \Abs{g : (\tau^K \R \bot^K) \R \bot}
  \\ &\Indent\Indent\hspace{2.5em}
  g~(\Abs{x:\tau^K} \Abs{\Id : (\bot \R \bot)} c~x)
  \\ &\Indent\Indent
  )~(\Abs{z:\bot} z)
\end{align*}

\begin{lemma}
[$\Undo$ and $\Redo$]
\label{lem:undo-redo}
For every type variable $\alpha$ and every type $\sigma$, there
exists a pair of computable metafunctions $\Undo_{\alpha,\sigma}$
and $\Redo_{\alpha,\sigma}$ such that
\begin{itemize}
\item
whenever
$\Gamma \vdash t : \tau^K[\alpha \mapsto (\sigma\R\bot)]$
we have
\[
\Gamma \vdash \Undo_{\alpha,\sigma}(t,\tau) :
  \tau^K[(\Dn\alpha) \mapsto (\sigma\R\bot)],
\]
\item
whenever
$\Gamma \vdash t' : \tau^K[(\Dn\alpha) \mapsto (\sigma\R\bot)]$
we have
\[
\Gamma \vdash \Redo_{\alpha,\sigma}(t',\tau) :
  \tau^K[\alpha \mapsto (\sigma\R\bot)].
\]
\end{itemize}
\end{lemma}

\begin{proof}
The proof consists essentially of threading double negation
introduction and Brouwer's double negation elimination
judiciously through a term of arbitrarily complex type. We shall
omit the subscripts $\alpha$, $\sigma$ and write simply $\Undo$,
$\Redo$ from now on. For every type $\rho$, write
\begin{align*}
\rho_1 & = \rho^K[(\Dn\alpha)\mapsto(\sigma\R\bot)],\\
\rho_2 & = \rho^K[\alpha\mapsto(\sigma\R\bot)].
\end{align*}
We will define $\Undo$ and $\Redo$ by induction on $\tau$.
\begin{align*}
\Undo(t,\alpha) & = \Bro~[\sigma]~t\\
\Redo(t',\alpha) & = \Dni~[\sigma]~t'\\
\\
\Undo(t,\rho\R\phi) & =
  \Abs{c : ((\rho_1 \R \phi_1) \R \bot)}
  t~(\Abs{f : \rho_2 \R \phi_2}\\
  &\Indent c~(\Abs{x : \rho_1}
  \Undo((f~\Redo(x, \rho)), \phi) ))\\
\Redo(t',\rho\R\phi) & =
  \Abs{c : ((\rho_2 \R \phi_2) \R \bot)}
  t'~(\Abs{f : \rho_1 \R \phi_1}\\
  &\Indent c~(\Abs{x : \rho_2}
  \Redo((f~\Undo(x, \rho)), \phi) ))\\
\\
\Undo(t, \All\beta \rho) & =
  \Abs{c : ((\All\beta \rho_1) \R \bot)}
  t~(\Abs{x : (\All\beta \rho_2)} \\
  &\Indent c~(\Tabs\beta \Undo(x~[\beta], \rho)) )\\
\Redo(t', \All\beta \rho) & =
  \Abs{c : ((\All\beta \rho_2) \R \bot)}
  t'~(\Abs{x : (\All\beta \rho_1)} \\
  &\Indent c~(\Tabs\beta \Redo(x~[\beta], \rho)) )\\
\\
\Undo(t, \Ex\beta \rho) & =
  \Abs{c : (\All\beta \rho_1 \R \bot)}
  t~(\Tabs\beta \Abs{x : \rho_2}
  c~[\beta]~\Undo(x,\rho) )\\
\Redo(t', \Ex\beta \rho) & =
  \Abs{c : (\All\beta \rho_2 \R \bot)}
  t'~(\Tabs\beta \Abs{x : \rho_1}
  c~[\beta]~\Redo(x,\rho) )\\
\\
\Undo(t,\bot) & = t \\
\Redo(t',\bot) & = t' \qedhere
\end{align*}
\end{proof}

\begin{lemma}
[substitution lemma for Kolmogorov's negative translation]
\label{lem:subst-kolmogorov}
\[
(\tau[\alpha\mapsto\sigma])^K =
\tau^K[(\Dn\alpha) \mapsto \sigma^K].
\]
\end{lemma}

\begin{proof}
[Proof by induction on $\tau$]
\end{proof}

\section{Unification of quantified names}
\label{sec:unify}

\end{document}
