\documentclass{amsart}
\usepackage{bcprules,url,enumerate}
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[subsection]{Definition}

\def\thesubsection{\arabic{subsection}}

\title{Nuclear Football Megaslave}

\input{../paper/macros.tex}
\begin{document}

\maketitle
\tableofcontents

\subsection{Syntax}
\begin{syntax}
\mbox{type}\\
\sigma, \tau
&::=& \iota_0 \Or \iota_1 \Or \cdots &\mbox{base type}\\
&|& \alpha \Or \beta \Or \cdots & \mbox{type variable} \\
&|& \tau \rightarrow \tau & \mbox{function type} \\
&|& \All\alpha\tau & \mbox{universal type} \\
&|& \Ex\alpha\tau & \mbox{existential type}
\\
\\
\mbox{term}\\
s, t & ::= & x & \mbox{variable} \\
& | & \Abs{x}t  & \mbox{lambda abstraction} \\
& | & t~t & \mbox{function application} \\
& | & \cdots & \mbox{primitives}
\end{syntax}

\subsection{Domain}
The domain of values $V$ is the solution to the following domain
equations.
\begin{align*}
V &= F + B_0 + B_1 + \cdots + \{\Wrong\}
  &&\mbox{disjoint sum of domains}\\
F &= V \R V &&\mbox{continuous functions from $V$ to $V$}
\end{align*}
Here and elsewhere, we omit all domain-theoretic details, such as
the fact that domain equations are solved only up to isomorphism,
and that disjoint sum with a bottomless set (say, $\{\Wrong\}$)
must be encoded as smash sum with a flat domain. To lighten
notational and conceptual burden, let us treat $B_i$, $F$ and
$\{\Wrong\}$ as if they were actual subsets of $V$.

\subsection{Denotation of terms}
\label{denotation-terms}
Terms denote values as in untyped lambda calculus. Primitives may
denote anything in $V$, as long as the value of each primitive
operator satisfies strong type soundness.

Upper case $\Env$ refers to a type-level environment.
(\S\ref{denotation-types}). Lower case $\env$ refers to a
term-level environment mapping term variables to values in $V$.
\begin{align*}
\Sem{x}~\env&=\env(x)\\
\Sem{\Abs{x}t}~\env&=
  f\in F\text{\quad such that\quad}
  f(v)=\Sem{t}~(\Update\env{x\mapsto v})
\\
\Sem{s~t}~\env&=
\begin{cases}
\bot&\text{if }(\Sem{s}~\env)=\bot
\\
f(\Sem{t}~\env)&\text{if }(\Sem{s}~\env)=f\in F
\\
\Wrong&\text{if }(\Sem{s}~\env)\notin F\cup\{\bot\}
\end{cases}
\\
\Sem{\mathrm{primitive}}~\env&=\cdots
\end{align*}

\subsection{Wrongless downsets}
\label{wrongless}
Closed types denote wrongless downsets. A subset $S$ of the
domain $V$ is \emph{downward closed} if for all $u\in S$, all
elements smaller than $u$ in $V$ are contained in $S$. A subset
of $V$ is a \emph{wrongless downset} if it is nonempty, downward
closed and does not contain $\Wrong$. Write $\Down$ for the
family of all wrongless downsets. $\Down$~is never empty;
$\{\bot\}$ is a wrongless downset, for example.

I'm not sure whether nonemptiness or downward closedness is
necessary for the type soundness proof. If they were not, then we
could set the denotation of types to arbitrary subsets of
$V-\{\Wrong\}$. Look forward to the grotesque scenarios that are
bound to ensue. One particular consequence is that nothing could
be allowed to have the type $\All\alpha\alpha$, not even
primitives.

\subsection{Functionality of wrongless downsets}
\label{functionality}
The functionality of wrongless down\-sets is the trivial
generalization of Milner's adaptation of Scott's notion of
functionality~\cite{Milner78}.

Let $S_0$ and $S_1$ be wrongless downsets. The
\emph{functionality} from $S_0$ to $S_1$, writ $S_0\RR S_1$, is
the set of functions that always map values in $S_0$ to values in
$S_1$, but can map values outside $S_0$ to anything in $V$,
including $\Wrong$.
\[
S_0 \RR S_1 =
\{\bot\}\cup\{f\in F \Or f(S_0) \subseteq S_1\}.
\]
Function types denote functionalities. A functionality is defined
to be inclusive enough to contain all polymorphic functions
capable of ``instantiating'' to the desired function type.

\subsection{Closure properties of wrongless downsets}
The functionality between two wrongless downsets is a wrongless
downset. The intersection of any nonempty family of wrongless
downsets is a wrongless downset. The union of any nonempty family
of wrongless downsets is a wrongless downset.

\subsection{Denotation of types}
\label{denotation-types}
Closed types denote wrongless downsets. Open types denote a
partial function mapping an environment of wrongless downsets to
a wrongless downset.

Upper case $\Env$ refers to an environment mapping type variables
to wrongless downsets; lower case $\env$ will refer to an environment
mapping term variables to values in \S\ref{denotation-terms}.
\begin{align*}
\Sem{\iota_i}~\Env &= \{\bot\}\cup B_i\\
\Sem{\alpha}~\Env &= \Env(\alpha)\\
\Sem{\sigma\R\tau}~\Env&=
  (\Sem{\sigma}~\Env)\RR(\Sem{\tau}~\Env)\\
\Sem{\All\alpha\tau}~\Env&=
  {\textstyle\bigcap_{S\in\Down}}
  \left(\Sem\tau~(\Update\Env{\alpha\mapsto S})\right)\\
\Sem{\Ex\alpha\tau}~\Env&=
  {\textstyle\bigcup_{S\in\Down}}
  \left(\Sem\tau~(\Update\Env{\alpha\mapsto S})\right)
\end{align*}
The reader may verify that the right hand side of this definition
is always a wrongless downset. The family $\Down$ of all
wrongless downsets is defined in \S\ref{wrongless}. The
functionality construction $\RR$ is described in
\S\ref{functionality}. Examples:
\begin{align*}
\Sem{\All\alpha\alpha}~\Env&=\{\bot\}\\
\Sem{\Ex\alpha\alpha}~\Env&=V-\{\Wrong\}
\end{align*}

\subsection{Equivalence of types}
Set-theoretic equality of the denotation of types induce an
equivalence relation on types. Examples:
\begin{enumerate}[(i)]
\item
$\Sem{\All\alpha\sigma\R\tau}=\Sem{\sigma\R(\All\alpha\tau)}$
where $\alpha\notin\FTV(\sigma)$,
\item
$\Sem{\Ex\alpha\sigma\R\tau}=\Sem{\sigma\R(\Ex\alpha\tau)}$
where $\alpha\notin\FTV(\sigma)$,
\item
$\Sem{\All\alpha\sigma\R\tau}=\Sem{(\Ex\alpha\sigma)\R\tau}$
where $\alpha\notin\FTV(\tau)$,
\item
$\Sem{\Ex\alpha\sigma\R\tau}=\Sem{(\All\alpha\sigma)\R\tau}$
where $\alpha\notin\FTV(\tau)$,
\item
$\Sem{\All\alpha\Ex\beta\tau}=\Sem{\Ex\beta\All\alpha\tau}$.
\end{enumerate}
Types on both sides of (i) or (ii) are equisatisfiable as
propositions of intuitionistic logic. Types on both sides of
(iii) or (iv) are equisatisfiable as propositions of classical
logic. The equivalence expressed by (v) is seen in neither.


\subsection{Syntax of subtype judgements}

We define a syntactic relation $\Sub$ on types. We call it the
\emph{subtype} relation because for closed types $\sigma$,
$\tau$, the relation $\sigma \Sub \tau$ implies that the
wrongless downset denoted by $\sigma$ is a \emph{subset} of the
wrongless downset denoted by $\tau$ (\S\ref{subsound}).

The symbol $\Sub$ stands for the partial order between values of
a domain in literature about domain theory. At the same time,
$\Sub$ stands for the ``more general'' partial order between
types in literature about parametric polymorphism. Our use of
$\Sub$ agrees with the latter.

\begin{syntax}
\mbox{list of type variables}\\
A,E
&::=& \emptyset \\
&|& \alpha,A
\\
\\
\mbox{list of constraints}\\
C
&::=& \emptyset \\
&|& \sigma \Sub \tau, C
\\
\\
\mbox{subtype judgement}
&::=&A;E\vdash C
\end{syntax}

In a judgement $A;E\vdash C$, the type variables in $A$ represent
wrongless downsets that can be chosen later so that constraints
in $C$ hold; they are \emph{accommodating}. The type variables in
$E$ represent demands that the constraints in $C$ must be
satisfiable whichever downsets are chosen for them; they are
\emph{exigent}.

\subsection{Derivation of subtype judgements}~

\infrule[S-Refl]
{}
{A;E \vdash \tau_0\Sub\tau_0,\tau_1\Sub\tau_1,
\ldots,\tau_n\Sub\tau_n}

\infrule[S-Arrow]
{A;E\vdash\tau_0\Sub\sigma_0,\sigma_1\Sub\tau_1,C}
{A;E\vdash\sigma_0\R\sigma_1\Sub\tau_0\R\tau_1,C}

\infrule[S-Loner]
{\alpha\notin A\cup E\cup\FTV(C)
\andalso
A;E\vdash
\{ \sigma_i\Sub\tau_j \Or 0 \le i \le m, 0 \le j \le n \}
\cup C
}{
\alpha,A;E \vdash
\sigma_0\Sub\alpha,\ldots,\sigma_m\Sub\alpha,
\alpha\Sub\tau_0,\ldots,\alpha\Sub\tau_n,C
}

\infrule[S-Al]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
\alpha,A;E\vdash\sigma\Sub\tau,C}
{A;E\vdash(\All\alpha\sigma)\Sub\tau,C}

\infrule[S-Ar]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
\alpha,A;E\vdash\sigma\Sub\tau,C}
{A;E\vdash\sigma\Sub(\Ex\alpha\tau),C}

\infrule[S-El]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
A;\alpha,E\vdash\sigma\Sub\tau,C}
{A;E\vdash(\Ex\alpha\sigma)\Sub\tau,C}

\infrule[S-Er]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
A;\alpha,E\vdash\sigma\Sub\tau,C}
{A;E\vdash\sigma\Sub(\All\alpha\tau),C}

% Reason of existence: T-App.
\infrule[S-Forget]
{C_0\subseteq C_1\andalso A;E\vdash C_1}
{A;E\vdash C_0}

\subsection{Accommodating extensions of exigent environments}
This is a concept necessary to appreciate how an open type can be
a subtype of another.

With respect to a subtype judgement $A;E\vdash C$, an environment
$\Env_0$ of wrongless downsets is an \emph{exigent environment}
if it is defined for every type variable in $E$ and nowhere else.
$\Env$ is an \emph{accommodating extension} of $\Env_0$ if $\Env$
is defined for every type variable in $A$ and agrees with
$\Env_0$ on $E$.

\subsection{Soundness of subtyping}
\label{subsound}
If the subtype judgement $A;E\vdash C$ is derivable, then every
exigent environment $\Env_0$ has an accommodating extension
$\Env$ such that for every constraint $\sigma\Sub\tau$ in $C$ we
have
\[
\Sem{\sigma}~\Env \quad \subseteq \quad \Sem{\tau}~\Env.
\]

\begin{proof}
Straightforward induction on a derivation of the subtype judgement.
\end{proof}

\subsection{Constrained typing}
\begin{syntax}
\mbox{constrained type}
&::=&\tau \Given C
\\\\
\mbox{constrained typing judgement}
&::=&A;E;\Gamma \vdash t : \tau \Given C
\end{syntax}

\infrule[T-Var]
{x:\tau\in\Gamma}
{A;\Gamma\vdash x : \tau \Given \emptyset}

\infrule[T-Abs]
{\FTV(\sigma)\subseteq A
\andalso
A;\Gamma,x:\sigma \vdash t : \tau \Given C}
{A;\Gamma\vdash (\Abs{x}t) : \sigma\R\tau \Given C}

\infrule[T-App]
{\alpha,\beta\text{ fresh}
\andalso
A;\Gamma\vdash s : \sigma \Given C_1
\andalso
A;\Gamma\vdash t : \tau \Given C_2}
{\alpha,\beta,A;\Gamma\vdash s~t : \beta \Given
\sigma\Sub\alpha\R\beta,\tau\Sub\alpha,C_1\cup C_2}

\subsection{Denotation of typing contexts}
The denotation of a typing context $\Gamma$ is a partial function
mapping an type-level environment to the set of compatible
term-level environments.
\begin{align*}
\Sem{\Gamma}~\Env&=
\left\{\env \Or
\env(x)\in(\Sem{\tau}~\Env)\text{ whenever }x:\tau\in\Gamma
\right\}
\end{align*}

\subsection{Soundness of constrained typing}
\label{consound}
If
\begin{align*}
A;\Gamma&\vdash t : \sigma\Given C&
&\text{and}&
A;\emptyset&\vdash\sigma\Sub\tau,C
\end{align*}
are both derivable, then there exist a type-level $\Env$ such
that for every term-level $\env\in(\Sem{\Gamma}~\Env)$ we have
$(\Sem{t}~\env)\in(\Sem{\tau}~\Env)$.

\begin{proof}
A fun induction on typing derivations.
\end{proof}

\subsection{Well-typed programs don't go wrong}
A term $t$ has type $\tau$ under typing context
$\Gamma$, writ $\Gamma\vdash t:\tau$, if both
\begin{align*}
A;&\Gamma\vdash t : \sigma\Given C&
&\text{and}&
A;\emptyset\vdash\sigma\Sub\tau,C
\end{align*}
are derivable for some $A$.

If $\emptyset\vdash t:\tau$ and $t$, $\tau$ are both closed, then
$\Sem{t}~\emptyset~\in~\Sem{\tau}~\emptyset$. In particular,
$\Sem{t}~\emptyset\neq\Wrong$. This is a corollary of
\S\ref{consound}.



\input{bib.tex}\end{document}
