\documentclass{amsart}
\usepackage{bcprules,url,enumerate}
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[subsection]{Definition}

\def\thesubsection{\arabic{subsection}}

\title{Nuclear Football Megaslave}

\input{../paper/macros.tex}
\begin{document}

\maketitle
\tableofcontents

\subsection{Syntax}
\begin{syntax}
\mbox{type}\\
\sigma, \tau
&::=& \iota_0 \Or \iota_1 \Or \cdots &\mbox{base type}\\
&|& \alpha \Or \beta \Or \cdots & \mbox{type variable} \\
&|& \tau \rightarrow \tau & \mbox{function type} \\
&|& \All\alpha\tau & \mbox{universal type}
\\
\\
\mbox{term}\\
s, t & ::= & x & \mbox{variable} \\
& | & \Abs{x}t  & \mbox{lambda abstraction} \\
& | & t~t & \mbox{function application} \\
& | & \cdots & \mbox{primitives}
\end{syntax}

\subsection{Domain}
The domain of values $V$ is the solution to the following domain
equations.
\begin{align*}
V &= F + B_0 + B_1 + \cdots + \{\Wrong\}
  &&\mbox{disjoint sum of domains}\\
F &= V \R V &&\mbox{continuous functions from $V$ to $V$}
\end{align*}
Here and elsewhere, we omit all domain-theoretic details, such as
the fact that domain equations are solved only up to isomorphism,
and that disjoint sum with a bottomless set (say, $\{\Wrong\}$)
must be encoded as smash sum with a flat domain. To lighten
notational and conceptual burden, let us treat $B_i$, $F$ and
$\{\Wrong\}$ as if they were actual subsets of $V$.

\subsection{Denotation of terms}
\label{denotation-terms}
Terms denote values as in untyped lambda calculus. Primitives may
denote anything in $V$, as long as the value of each primitive
operator satisfies strong type soundness.

Upper case $\Env$ will refer to type-level environments
(\S\ref{denotation-types}). Lower case $\env$ refers to a
term-level environment mapping term variables to values in $V$.
\begin{align*}
\Sem{x}~\env&=\env(x)\\
\Sem{\Abs{x}t}~\env&=
  f\in F\text{\quad such that\quad}
  f(v)=\Sem{t}~(\Update\env{x\mapsto v})
\\
\Sem{s~t}~\env&=
\begin{cases}
\bot&\text{if }(\Sem{s}~\env)=\bot
\\
f(\Sem{t}~\env)&\text{if }(\Sem{s}~\env)=f\in F
\\
\Wrong&\text{if }(\Sem{s}~\env)\notin F\cup\{\bot\}
\end{cases}
\\
\Sem{\mathrm{primitive}}~\env&=\cdots
\end{align*}

\subsection{Ideals}
\label{ideal}
Ideals are the traditional denotation assigned to types. TODO:
write detailed definition here.

Write $\Ideals$ for the family of ideals of $V-\{\Wrong\}$. It is
always nonempty, because $\{\bot\}$ and ${V-\{\Wrong\}}$ are both
ideals.

We say ``$u$ precedes $v$'' to mean that $u$, $v$ are related by
the inherent partial order in the domain $V$. Intuitively, if $u$
precedes $v$, then $u$ has at most as much information as $v$ and
the information in $u$ never conflicts with the information in
$v$. The function undefined everywhere precedes the function that
acts as the identity between integers and is undefined elsewhere,
which in turn precedes the identity function over all of $V$.

\subsection{Functionality of ideals}
\label{functionality}
Let $S_0$ and $S_1$ be ideals. The \emph{functionality} from
$S_0$ to $S_1$, writ $S_0\RR S_1$, is the set that consists of
$\bot$ and all functions who always map values in $S_0$ to values
in $S_1$, but may map values outside $S_0$ to anything in $V$,
including $\Wrong$.
\[
S_0 \RR S_1 =
\{\bot\}\cup\{f\in F \Or f(S_0) \subseteq S_1\}.
\]
Function types denote functionalities. Functionalities are
defined to be inclusive enough to contain all appropriate
polymorphic function values. The functionality from integers to
integers will also contain the identity function on all of $V$,
for example.

The functionality of ideals is described in
Milner~\cite{Milner78} and attributed to Dana Scott.

\subsection{Closure properties of ideals}
The functionality between two ideals is an ideal. The
intersection of a nonempty family of ideals is an ideal.

\subsection{Denotation of types}
\label{denotation-types}
Closed types denote ideals. Open types denote a partial function
mapping a type-level environment to an ideal.

Upper case $\Env$ refers to a type-level environment mapping each
type variable to an ideal. Lower case $\env$ refers to a
term-level environment mapping term variables to values
(\S\ref{denotation-terms}).
\begin{align*}
\Sem{\iota_i}~\Env &= \{\bot\}\cup B_i\\
\Sem{\alpha}~\Env &= \Env(\alpha)\\
\Sem{\sigma\R\tau}~\Env&=
  (\Sem{\sigma}~\Env)\RR(\Sem{\tau}~\Env)\\
\Sem{\All\alpha\tau}~\Env&=
  {\textstyle\bigcap_{S\in\Ideals}}
  \left(\Sem\tau~(\Update\Env{\alpha\mapsto S})\right)
\end{align*}
The reader may verify that the right hand side of this definition
is always an ideal. The family $\Ideals$ of all ideals is defined
in \S\ref{ideal}. The functionality construction $\RR$ is
described in \S\ref{functionality}.

\subsection{Examples of type denotations}
\label{free-theorems}
~
\begin{enumerate}[(a)]
\item $\Sem{\All\alpha\alpha}~\emptyset=\{\bot\}$
\item $\Sem{\All\alpha\alpha\R\alpha}~\emptyset=\{\bot\}\cup
\{f\in F
\Or
f(v)\text{ precedes }v\text{ for all }v\neq\Wrong
\}$
\end{enumerate}

Equation (a) holds because $\{\bot\}$ is an ideal and all ideals,
by their nonemptiness and downward closedness, contains $\bot$.

Equation (b) says that every member $f$ of the type
$\All\alpha\alpha\R\alpha$ maps each value~$v$ either to itself
or to a less informative version of itself. If $n$ is an integer,
then $f(n)$ would have to be $n$ or $\bot$. \S\ref{ideal}
contains a discussion about the intuition behind the inherent
partial order of a domain invoked in the phrase ``$f(v)$ precedes
$v$''.

For (b), we show that its left hand side and right hand side are
subsets of each other. The $\supseteq$ direction holds due to the
definition of functionality, and because $\bot$ is a member of
every ideal. The $\subseteq$ direction requires case analysis.
Choose $f\in\Sem{\All\alpha\alpha\R\alpha}~\emptyset$. If
$f=\bot$, then $f$ is a member of the right hand side. If
$f\neq\bot$, then $f\in F$, as it is a member of some
functionality. Choose~$v\neq\Wrong$. The set $S$ of everything
preceding $v$ is an ideal. Since $v\in S$ and
$f(S)\subseteq S$, we have $f(v)\in S$ and thus precedes $v$.

\subsection{Ecospheres}

An \emph{ecosphere} is a set of sequences of ideals indexed by
type variables. Each ecosphere $\Eco$ has enough information to
construct an ideal from any type $\tau$. One may regard each
$\Eco$ as a nonstandard semantic function.
\[
\Eco[\tau] \quad =
\bigcap_{S_\alpha,\ldots,S_\omega\in \Eco}
\Sem\tau~(\alpha\mapsto S_\alpha,\ldots,\omega\mapsto S_\omega)
\]
The meanings of closed types are invariant with respect to
ecospheres and to environments. If $\tau$ is closed, then for all
ecosphere~$\Eco$ and type-level environment~$\Env$ we have
\[
\Eco[\tau] = \Sem{\tau}~\Env = \Sem{\tau}~\emptyset.
\]

\subsection{Union of of ecospheres}
The union of ecospheres takes types to the intersections of
corresponding ideals.
\[
\left(\bigcup_i\Eco_i\right)[\tau]
=
\bigcap_i\Eco_i[\tau]
\]
The union of ecospheres preserves ideal containment. If for every
$j$ we have
\[
\Eco_j[\sigma]\subseteq\Eco_j[\tau],
\]
then
\[
\left(\bigcup_i\Eco_i\right)[\sigma]
\subseteq
\left(\bigcup_i\Eco_i\right)[\tau]
\]

\subsection{Syntax of subtype judgements}

We define a syntactic relation $\Sub$ on types. We call it the
\emph{subtype} relation because for closed types $\sigma$,
$\tau$, the relation $\sigma \Sub \tau$ implies that the ideal
denoted by $\sigma$ is a \emph{subset} of the ideal denoted by
$\tau$ (\S\ref{subsound}).
\begin{syntax}
\mbox{list of type variables}\\
A,E
&::=& \emptyset \\
&|& \alpha,A
\\
\\
\mbox{list of constraints}\\
C
&::=& \emptyset \\
&|& \sigma \Sub \tau, C
\\
\\
\mbox{subtype judgement}
&::=&A;E\vdash C
\end{syntax}%
In a judgement $A;E\vdash C$, the type variables in $A$ represent
ideals that can be chosen later so that constraints in $C$ hold;
they are \emph{accommodating}. The type variables in $E$
represent demands that the constraints in $C$ must be satisfiable
whichever ideals are chosen for them; they are \emph{exigent}.

\subsection{Derivation of subtype judgements}~

\infrule[S-vacuous]
{}
{A;E\vdash\emptyset}

\infrule[S-Refl]
{\FTV(\tau)\subseteq A\cup E
\andalso
A;E\vdash C
}
{A;E \vdash \tau\Sub\tau,C}

\infrule[S-Arrow]
{A;E\vdash\tau_0\Sub\sigma_0,\sigma_1\Sub\tau_1,C}
{A;E\vdash\sigma_0\R\sigma_1\Sub\tau_0\R\tau_1,C}

\infrule[S-Loner]
{\alpha\notin A\cup E\cup\FTV(C)
\andalso
A;E\vdash
\{ \sigma_i\Sub\tau_j \Or 0 \le i \le m, 0 \le j \le n \}
\cup C
}{
\alpha,A;E \vdash
\sigma_0\Sub\alpha,\ldots,\sigma_m\Sub\alpha,
\alpha\Sub\tau_0,\ldots,\alpha\Sub\tau_n,C
}

\infrule[S-Al]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
\alpha,A;E\vdash\sigma\Sub\tau,C}
{A;E\vdash(\All\alpha\sigma)\Sub\tau,C}

\infrule[S-Er]
{\alpha\notin A\cup E\cup\FTV(\tau)\cup\FTV(C)
\andalso
A;\alpha,E\vdash\sigma\Sub\tau,C}
{A;E\vdash\sigma\Sub(\All\alpha\tau),C}

% Reason of existence: T-App.
\infrule[S-Forget]
{C_0\subseteq C_1\andalso A;E\vdash C_1}
{A;E\vdash C_0}

\subsection{Accommodating extensions of exigent ecospheres}
This is a concept necessary to appreciate how an open type can be
a subtype of another.

TODO: Define me.

\subsection{Soundness of subtyping}
\label{subsound}
If the subtype judgement $A;E\vdash C$ is derivable, then every
exigent ecosphere $\Eco_0$ has an accommodating extension $\Eco$
such that for every constraint $\sigma\Sub\tau$ in $C$ we have
\[
\Eco[\sigma] \subseteq \Eco[\tau].
\]

\begin{proof}
The proof is an induction on a derivation of the subtype
judgement.

If \textsc{S-Vacuous} is the last rule used, then the proof goal
is vacuously true.

If \textsc{S-Refl} is the last rule used, then the proof goal is
the tautology that some sets to be subsets of themselves.

TODO: Complete this.
\end{proof}

\subsection{Constrained typing}
\begin{syntax}
\mbox{constrained type}
&::=&\tau \Given C
\\\\
\mbox{constrained typing judgement}
&::=&A;E;\Gamma \vdash t : \tau \Given C
\end{syntax}%
\infrule[CT-Var]
{x:\tau\in\Gamma}
{A;\Gamma\vdash x : \tau \Given \emptyset}

\infrule[CT-Abs]
{\FTV(\sigma)\subseteq A
\andalso
A;\Gamma,x:\sigma \vdash t : \tau \Given C}
{A;\Gamma\vdash (\Abs{x}t) : \sigma\R\tau \Given C}

\infrule[CT-App]
{\alpha,\beta\text{ fresh}
\andalso
A;\Gamma\vdash s : \sigma \Given C_1
\andalso
A;\Gamma\vdash t : \tau \Given C_2}
{\alpha,\beta,A;\Gamma\vdash s~t : \beta \Given
\sigma\Sub\alpha\R\beta,\tau\Sub\alpha,C_1\cup C_2}

\subsection{Denotation of typing contexts}
The denotation of a typing context $\Gamma$ is a partial function
mapping ecospheres to the set of compatible
term-level environments.
\begin{align*}
\Sem{\Gamma}~\Eco&=
\left\{\env \Or
\env(x)\in\Eco[\tau]\text{ whenever }x:\tau\in\Gamma
\right\}
\end{align*}

\subsection{Soundness of constrained typing}
\label{consound}
If
$A;\Gamma\vdash t : \sigma\Given C$ and
$A;\emptyset\vdash{\sigma\Sub\tau},C$
are both derivable, then there exist an ecosphere $\Eco$ such
that for every term-level $\env\in(\Sem{\Gamma}~\Eco)$ we have
$(\Sem{t}~\env)\in\Eco[\tau]$.

\begin{proof}
A fun and not-at-all complicated induction on typing derivations.
\end{proof}

\subsection{Well-typed programs don't go wrong}~

\infrule[T]
{
A;\emptyset\vdash\sigma\Sub\tau,C
\andalso
A;\Gamma\vdash t : \sigma\Given C
}
{t:\tau}

A term $t$ has type $\tau$, writ $t:\tau$, if both
$A;\Gamma\vdash t : \sigma\Given C$ and
$A;\emptyset\vdash\sigma\Sub\tau,C$ are derivable for some $A$,
$\Gamma$.

If $t:\tau$ with $t$, $\tau$ both closed, then
$\Sem{t}~\emptyset~\in~\Sem{\tau}~\emptyset$. In particular,
$\Sem{t}~\emptyset\neq\Wrong$. This is a corollary of
\S\ref{consound}.



\input{bib.tex}\end{document}
