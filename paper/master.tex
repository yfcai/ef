% latex
\documentclass{amsart}
\usepackage{bcprules,url}
\title
[Impredicative type inference]
{
Impredicative type inference
\break
or
\break
partial proof reconstruction \break
for second-order classical logic
}

\let\phi=\varphi % default phi looks like empty set
\allowdisplaybreaks
\swapnumbers
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{lemma}[subsection]{Lemma}

\begin{document}
\newcommand{\nc}{\newcommand}
\newcommand{\DotExpr}[2]{#1 #2.\ }
\nc\Abs    {\DotExpr\lambda}
\nc\All    {\DotExpr\forall}
\nc\Allin  {\forall\mathrm{in}}
\nc\Allex  {\forall\mathrm{ex}}
\nc\Abort  {\mathrm{abort}}
\nc\AbortCC{\mathrm{abort/cc}}
\nc\ApplyCC{\mathrm{apply/cc}}
\def\Box   {\mathrm{box}}
\nc\Brouwer{\operatorname{Brouwer}}
\nc\Case   {}
\nc\Cps    {\operatorname{cps}}
\nc\Dn[1]  {(#1 \R \bot) \R \bot}
\nc\Dni    {\mathrm{\neg\neg I}}
\nc\Erase  {\mathrm{erase}}
\nc\Ex     {\DotExpr\exists}
\nc\Exin   {\exists\mathrm{in}}
\nc\Exex   {\exists\mathrm{ex}}
\nc\FV     {\operatorname{FV}}
\nc\Id     {\mathit{id}}
\nc\Indent {\hspace{3em}}
\nc\Mgsr   {\operatorname{mgsr}}
\nc\Or     {\ | \ }
\nc\Prune  {\operatorname{prune}}
\nc\Recall {\DotExpr\Xi} % looks like âˆƒ
\nc\Redo   {\operatorname{redo}}
\nc\Tabs   {\DotExpr\Lambda}
\nc\R      {\rightarrow}
\nc\Unbox  {\mathrm{unbox}}
\nc\Undo   {\operatorname{undo}}
\nc\Unify  {\operatorname{unify}}
\maketitle
\tableofcontents

\section{Introduction}

Existential F is a language with
\begin{itemize}
\item first-class existential types,
\item impredicative polymorphism, and
\item decidable typing of Church-style terms.
\end{itemize}
It bears emphasis that Existential F has more permissive
existential types than the traditional encoding of existentials
in System F. If we think harder, maybe we could come up with an
example of greater practical benefit than moving quantifiers
around.

\section{Executive summary of simplicity of implementation}
\label{sec:exe}

Existential~F is very easy to implement. We can simply erase all
types from terms in Existential~F and feed the result to some
implementation of untyped lambda calculus. The following theorem
explains why it works.

\begin{theorem}
[faithfulness of $\Cps$]
\label{thm:faith}
Suppose $\Gamma\vdash t : \tau$ in Existential~F. Choose any
variable ``\/$\Abort$'' not free in $t$. Then $(\Cps(t)~\Abort)$
reduces to $(\Abort~t')$ in System~F, such that $t'$ erases to an
untyped lambda term $\beta$-equivalent to the erased version of $t$.
\end{theorem}

In theorem~\ref{thm:faith}, we have taken the liberty to
call the translation from Existential~F to System~F ``$\Cps$''.
In truth, the translation consists of desugaring into
Continuation Calculus (\S\ref{sec:desugar}) followed by
the continuation-passing-style transformation (\S\ref{sec:cps}).

The HMF paper\footnote {Daan Leijen. HMF: simple type inference
for first-class polymorphism. } demonstrates type soundness of
HMF by translating HMF terms into System~F. It declares that type
soundness follows from the following conditions.
\begin{enumerate}
\item The translation is sound: Well-typed HMF terms are
translated to System~F terms of the same type.
\item The translation is faithful: If $t$ translates to $t'$,
then erasing $t$ and $t'$ yields $\beta$-equivalent terms in
untyped lambda calculus.
\end{enumerate}
It remains to investigate what kind of type soundness follows
from these conditions, why it does, and what its analogy is for
Existential~F.

\section{Existential F}

\subsection{Grammar of Existential F}

\nc\Ftype{
\tau & ::= & \alpha & \mbox{type variable} \\
&\Or& \tau \rightarrow \tau & \mbox{function type} \\
&\Or& \All\alpha\tau & \mbox{universal type} \\
}

\nc\CFtype{
\Ftype
&\Or& \Ex\alpha\tau & \mbox{existential type} \\
}

\nc\CFterm{
t & ::= & x & \mbox{variable} \\
&\Or& \Abs{x:\tau}t  & \mbox{lambda abstraction} \\
&\Or& t~t & \mbox{function application} \\
}

\nc\SelectiveTypeAmnesia{
&\Or& t~\{\Ex\alpha\tau\} & \mbox{selective type amnesia} \\
}

\nc\TypingContexts{
\Gamma & ::= & \Gamma, x : \tau & \mbox{term variable binding}\\
&\Or& \Gamma, \alpha& \mbox{type variable binding} \\
&\Or& \epsilon & \mbox{empty context}\\ \\
}

\[
\begin{array}{lclr}
% types
\CFtype
\\
% terms
\CFterm
\SelectiveTypeAmnesia
\\
% contexts
\TypingContexts
\end{array}
\]

\subsection{Typing of Existential F}
~

\nc\Tautology{
\infrule[Taut]
{x : \tau \in \Gamma}
{\Gamma \vdash x : \tau}
}

\nc\UniversalIntroduction{
\infrule[$\forall$I]
{\Gamma,\alpha \vdash t:\tau
  \andalso \alpha \notin \Gamma}
{\Gamma \vdash (\Tabs\alpha t) : \All\alpha\tau}
}

\nc\ExistentialIntroduction{
\infrule[$\exists$I]
{\Gamma \vdash t : \tau[\alpha\mapsto\sigma]}
{\Gamma \vdash t~\{\Ex\alpha\tau\} : \Ex\alpha\tau}
}

\nc\UniversalNegation{
\infrule[$\neg\forall$]
{\Gamma \vdash t : (\All\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \Ex\alpha \sigma \R \tau}
}

\nc\ExistentialNegation{
\infrule[$\neg\exists$]
{\Gamma \vdash t : (\Ex\alpha\sigma) \R \tau
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash t : \All\alpha \sigma \R \tau}
}

\nc\SuperIntroduction{
\infrule[$\R\forall$I]
{\Gamma, A, x:\sigma \vdash t : \tau
  \andalso A = \FV(\sigma) - \Gamma}
{\Gamma \vdash (\Abs{x:\sigma}t) : \All A{\sigma\R\tau}}
}

\nc\SuperElimination{
\infrule[$\R\forall\exists$E]
{\Gamma \vdash s : \All{A} \Ex{E} \sigma_s \R \tau
  \andalso \Gamma \vdash t : \sigma_t \\
  \Unify(\All E \Ex A \sigma_s, \sigma_t) \downarrow \Mgsr}
{\Gamma \vdash s~t : \Mgsr(\tau)}
}

\Tautology

\SuperIntroduction

\SuperElimination

Unification is discussed in \S\ref{sec:unify}. The type-level
metafunction $\Mgsr$ stands for ``most general substitution and
requantification''.

\ExistentialIntroduction

\section{Continuation Calculus}

\subsection{Grammar of Continuation Calculus}

\nc\Fterm{
\CFterm
&\Or& \Tabs\alpha t & \mbox{type abstraction} \\
&\Or& t~[\tau] & \mbox{type application} \\
}

\[
\begin{array}{lclr}
% types
\Ftype
&\Or& \bot & \mbox{result type of continuations} \\
\\
% terms
\Fterm
&\Or& \AbortCC~t & \mbox{abort with current continuation} \\
&\Or& \ApplyCC~t~t & \mbox{apply with current continuation} \\
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of Continuation Calculus}
~

\nc\UniversalElimination{
\infrule[$\forall$E]
{\Gamma \vdash t : \All\alpha\tau
   \andalso \FV(\sigma)\subseteq \Gamma}
{\Gamma \vdash t~[\sigma] : \tau[\alpha\mapsto\sigma]}
}

\nc\FRules{
\Tautology
%
\infrule[$\R$I]
{\Gamma,x:\sigma \vdash t : \tau
  \andalso \FV(\sigma) \subseteq \Gamma}
{\Gamma \vdash (\Abs{x:\sigma}t) : \sigma\R\tau}
%
\infrule[$\R$E]
{\Gamma\vdash s:\sigma\R\tau
  \andalso \Gamma\vdash t:\sigma}
{\Gamma\vdash s~t:\tau}
%
\UniversalIntroduction
%
\UniversalElimination
}

\nc\ExistentialElimination{
\infrule[$\exists$E]
{\Gamma \vdash s : \All\alpha \sigma\R\tau
  \andalso \Gamma \vdash t : (\All\alpha \sigma\R\bot) \R \bot
  \andalso \alpha \notin \FV(\tau)}
{\Gamma \vdash \ApplyCC~s~t:\tau}
}

\nc\DoubleNegationElimination{
\infrule[$\neg\neg$E]
{\Gamma \vdash t : \Dn{\tau}}
{\Gamma \vdash \AbortCC~t : \tau}
}

\FRules

\DoubleNegationElimination

\ExistentialElimination

\subsection{Useful term families of Continuation Calculus}

Since System F is a subset of Continuation Calculus, the useful
terms $\Brouwer$ and $\Dni$ of System F (\S\ref{sec:f-terms},
page~\pageref{sec:f-terms}) are also useful terms of Continuation
Calculus. The terms here deal with pushing quantifiers into the
argument positions of functions, and with pulling them out of
there. They are type-indexed term families, but members of one
family differ from each other in annotated types only.

Unlike Existential F, there is no primitive existential
quantifier in Continuation Calculus. Instead, we define it as a
syntactic sugar.
\[
\Ex\alpha \tau ::= (\All\alpha \tau \R \bot) \R \bot
\]

Traditional introduction and elimination forms are easy to
encode.
\begin{align*}
\Box_{\sigma,\tau} & :
  \tau[\alpha\mapsto\sigma] \R \Ex\alpha\tau
  \\
\Box_{\sigma,\tau} & =
  \Abs{x : \tau[\alpha\mapsto\sigma]}
  \Abs{f : (\All\alpha \tau \R \bot)}
  f~[\sigma]~x
\end{align*}
%
\begin{align*}
\Unbox_{\sigma} & :
  (\Ex\alpha\sigma) \R
  (\All\beta (\All\alpha \sigma \R \beta) \R \beta)
  \\
\Unbox_{\sigma} & =
  \Abs{x : (\Ex\alpha\sigma)}
  \Tabs\beta
  \Abs{f : (\All\alpha \sigma \R \beta)}
  \ApplyCC~f~x
\end{align*}

The following are theorems in classical predicate calculus.
Consult Metamath.\footnote{
~\url{http://de.metamath.org/mpegif/19.35.html}
}
\begin{align*}
\Allin_\sigma & : \All\beta
  (\All\alpha \sigma\R\beta) \R
  (\Ex\alpha \sigma) \R \tau
  \\
\Allin_\sigma & = ~?
\end{align*}

\begin{align*}
\Allex_\sigma & : \All\beta
  ((\All\alpha\sigma) \R \beta) \R
  (\Ex\alpha \sigma \R \beta)
  \\
\Allex_\sigma & = ~?
\end{align*}

\begin{align*}
\Exex_\sigma & : \All\beta
  ((\Ex\alpha \sigma) \R \beta) \R
  (\All\alpha \sigma \R \beta)
  \\
\Exex_\sigma & = ~?
\end{align*}

\begin{align*}
\Exin_\sigma & : \All\beta
  (\Ex\alpha \sigma \R \beta) \R
  (\All\alpha\sigma) \R \beta
  \\
\Exin_\sigma & = ~?
\end{align*}

\subsection{Embedding Existential F in Continuation Calculus}
\label{sec:desugar}

\section{System F}

\subsection{Grammar of System F}

\[
\begin{array}{lclr}
\Ftype
&\Or& \bot & \mbox{bottom type} \\
\\
\Fterm
\\
\TypingContexts
\end{array}
\]

\subsection{Typing of System F}
~

\FRules

\subsection{Useful terms of System F}
\label{sec:f-terms}

\begin{align*}
\Dni & : \All\alpha \alpha \R (\Dn\alpha) \\
\Dni & = \Tabs\alpha \Abs{x:\alpha}
           \Abs{c : (\alpha \R \bot)} c~x
\end{align*}

\begin{align*}
\Brouwer & : \All\alpha (\Dn{(\alpha\R\bot)}) \R (\alpha \R \bot) \\
\Brouwer & = \Tabs\alpha \Abs{f:(\Dn{(\alpha\R\bot)})}
           \Abs{x:\alpha} f~(\Dni~[\alpha]~x)
\end{align*}

\subsection{Embedding Continuation Calculus in System F}
\label{sec:cps}

Fischer's CPS transformation extended by Felleisen, typed and
described by Timothy G. Griffin in ``A formula-as-types notion of
control''.

\begin{align*}
\alpha^* & =
  \alpha
  \\
(\sigma \R \tau)^* & =
  \sigma^* \R \Dn{\tau^*}
  \\
(\All\alpha\tau)^* & =
  \All\alpha (\Dn{\tau^*})
  \\
\bot^* & =
  \bot
\end{align*}

\begin{align*}
(\Gamma, x:\tau)^* & =
  \Gamma^*, x:\tau^*
  \\
(\Gamma, \alpha)^* & =
  \Gamma^*, \alpha
  \\
\epsilon^* & =
  \epsilon
\end{align*}

% cps: general scheme
In general, if $\Gamma \vdash t : \tau$, then
$\Gamma^* \vdash \Cps(t) : \Dn{\tau^*}$.
We define $\Cps$ by induction on the term component of the
judgement. Type annotations in the result of cps-transformation
are taken from the last rule in the typing derivation of the
input of cps-transformation.

% cps: tautology
\begin{align*}
\Cps(x)
& =
\Abs{k: (\tau^* \R \bot)} k~x
\end{align*}

% cps: implication introduction
\begin{align*}
\Cps(\Abs{x:\sigma}t)
& =
\Abs{k:\sigma^* \R \Dn{\tau^*}}
\\&\Indent
k~(\Abs{x:\sigma^*}\Cps(t))
\end{align*}

% cps: implication elimination
\begin{align*}
\Cps(s~t)
& =
\Abs{k:\tau^*\R\bot}
\\&\Indent
\Cps(s)~(\Abs{f:\sigma^* \R \Dn{\tau^*}}
\\&\Indent\hspace{5em}
\Cps(t)~(\Abs{x:\sigma^*}
f~x~k
))
\end{align*}

% cps: universal introduction
\begin{align*}
\Cps(\Tabs\alpha t)
& =
\Abs{k:((\All\alpha \Dn{\tau^*}) \R \bot)}
\\&\Indent
k~(\Tabs\alpha \Cps(t))
\end{align*}

% cps: universal elimination
\begin{align*}
\Cps(t~[\sigma])
& =
\Abs{k : \tau^*[\alpha\mapsto\sigma^*] \R \bot}
\\&\Indent
\Cps(t)~[\sigma^*]~(\Abs{x : \tau^*[\alpha\mapsto\sigma]} k~x)
\end{align*}

% cps: abort/cc
\begin{align*}
\Cps(\AbortCC~t)
& =
\Abs{k : \tau^*\R\bot}
\\&\Indent
\Cps(t)~(\Abs{x : (\tau^*\R\Dn\bot)\R\Dn\bot}
\\&\Indent\hspace{5em}
x~(\Abs{y : \tau^*} \Abs{\Id : (\bot\R\bot)}
\\&\Indent\hspace{8em}
k~y)~(\Abs{z : \bot}z))
\end{align*}

% cps: apply/cc
\begin{align*}
\Cps(\ApplyCC~s~t)
& =
\Abs{k : \tau^* \R \bot}
\\&\hspace{2em}
\Cps(s)~(\Abs{f : \All\alpha
  ((\sigma^*\R(\tau^*\R\bot)\R\bot)\R\bot)\R\bot}
\\&\Indent
\Cps(t)~(\Abs{w :
  (\All\alpha((\sigma^*\R \Dn\bot)\R\bot)\R\bot) \R
  \\&\Indent\hspace{5.5em}
  (\bot\R\bot) \R \bot}
\\&\Indent\hspace{1em}
w~(\Tabs\alpha \Abs{y :
  (\sigma^* \R \Dn\bot) \R \bot}
\\&\Indent\hspace{2em}
x~(\Abs{y : \sigma^*} \Abs{\Id : \bot \R \bot}
\\&\Indent\hspace{3em}
f~[\alpha]~(\Abs{g : \sigma^* \R \Dn{\tau^*}}
\\&\Indent\hspace{4em}
g~y~k))
\\&\Indent\hspace{1em}
)~(\Abs{z:\bot}z)
\end{align*}

\section{Faithfulness of the translation from Existential~F to
System~F}
\label{sec:faith}

This section proves theorem~\ref{thm:faith}.


\section{Unification of quantified names}
\label{sec:unify}

\section{Future work}

Support algebraic data types. We can pull out quantifiers from
the argument of a covariant type constructor (lists, tuples,
sums) just so, and we can pull out quantifiers from the argument
of a contravariant type constructor changing universals to
existentials and vice versa. I don't know what to do about
invariant type constructors. Maybe we just leave the quantifiers
inside their arguments and never try to unify them.

Let user define new typing rules for Existential F in
Continuation Calculus.

\end{document}
